var spine;!function(t){class Animation{constructor(t,e,n){if(null==t)throw new Error("name cannot be null.");if(null==e)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.timelineIds=[];for(var i=0;i<e.length;i++)this.timelineIds[e[i].getPropertyId()]=!0;this.duration=n}hasTimeline(t){return 1==this.timelineIds[t]}apply(t,e,n,i,a,s,r,l){if(null==t)throw new Error("skeleton cannot be null.");i&&0!=this.duration&&(n%=this.duration,e>0&&(e%=this.duration));let o=this.timelines;for(let i=0,h=o.length;i<h;i++)o[i].apply(t,e,n,a,s,r,l)}static binarySearch(t,e,n=1){let i=0,a=t.length/n-2;if(0==a)return n;let s=a>>>1;for(;;){if(t[(s+1)*n]<=e?i=s+1:a=s,i==a)return(i+1)*n;s=i+a>>>1}}static linearSearch(t,e,n){for(let i=0,a=t.length-n;i<=a;i+=n)if(t[i]>e)return i;return-1}}let e,n,i;t.Animation=Animation,function(t){t[t.setup=0]="setup",t[t.first=1]="first",t[t.replace=2]="replace",t[t.add=3]="add"}(e=t.MixBlend||(t.MixBlend={})),function(t){t[t.mixIn=0]="mixIn",t[t.mixOut=1]="mixOut"}(n=t.MixDirection||(t.MixDirection={})),function(t){t[t.rotate=0]="rotate",t[t.translate=1]="translate",t[t.scale=2]="scale",t[t.shear=3]="shear",t[t.attachment=4]="attachment",t[t.color=5]="color",t[t.deform=6]="deform",t[t.event=7]="event",t[t.drawOrder=8]="drawOrder",t[t.ikConstraint=9]="ikConstraint",t[t.transformConstraint=10]="transformConstraint",t[t.pathConstraintPosition=11]="pathConstraintPosition",t[t.pathConstraintSpacing=12]="pathConstraintSpacing",t[t.pathConstraintMix=13]="pathConstraintMix",t[t.twoColor=14]="twoColor"}(i=t.TimelineType||(t.TimelineType={}));class CurveTimeline{constructor(e){if(e<=0)throw new Error("frameCount must be > 0: "+e);this.curves=t.Utils.newFloatArray((e-1)*CurveTimeline.BEZIER_SIZE)}getFrameCount(){return this.curves.length/CurveTimeline.BEZIER_SIZE+1}setLinear(t){this.curves[t*CurveTimeline.BEZIER_SIZE]=CurveTimeline.LINEAR}setStepped(t){this.curves[t*CurveTimeline.BEZIER_SIZE]=CurveTimeline.STEPPED}getCurveType(t){let e=t*CurveTimeline.BEZIER_SIZE;if(e==this.curves.length)return CurveTimeline.LINEAR;let n=this.curves[e];return n==CurveTimeline.LINEAR?CurveTimeline.LINEAR:n==CurveTimeline.STEPPED?CurveTimeline.STEPPED:CurveTimeline.BEZIER}setCurve(t,e,n,i,a){let s=.03*(2*-e+i),r=.03*(2*-n+a),l=.006*(3*(e-i)+1),o=.006*(3*(n-a)+1),h=2*s+l,d=2*r+o,u=.3*e+s+.16666667*l,c=.3*n+r+.16666667*o,m=t*CurveTimeline.BEZIER_SIZE,f=this.curves;f[m++]=CurveTimeline.BEZIER;let g=u,p=c;for(let t=m+CurveTimeline.BEZIER_SIZE-1;m<t;m+=2)f[m]=g,f[m+1]=p,u+=h,c+=d,h+=l,d+=o,g+=u,p+=c}getCurvePercent(e,n){n=t.MathUtils.clamp(n,0,1);let i=this.curves,a=e*CurveTimeline.BEZIER_SIZE,s=i[a];if(s==CurveTimeline.LINEAR)return n;if(s==CurveTimeline.STEPPED)return 0;a++;let r=0;for(let t=a,e=a+CurveTimeline.BEZIER_SIZE-1;a<e;a+=2)if(r=i[a],r>=n){let e,s;return a==t?(e=0,s=0):(e=i[a-2],s=i[a-1]),s+(i[a+1]-s)*(n-e)/(r-e)}let l=i[a-1];return l+(1-l)*(n-r)/(1-r)}}CurveTimeline.LINEAR=0,CurveTimeline.STEPPED=1,CurveTimeline.BEZIER=2,CurveTimeline.BEZIER_SIZE=19,t.CurveTimeline=CurveTimeline;class RotateTimeline extends CurveTimeline{constructor(e){super(e),this.frames=t.Utils.newFloatArray(e<<1)}getPropertyId(){return(i.rotate<<24)+this.boneIndex}setFrame(t,e,n){t<<=1,this.frames[t]=e,this.frames[t+RotateTimeline.ROTATION]=n}apply(t,n,i,a,s,r,l){let o=this.frames,h=t.bones[this.boneIndex];if(!h.active)return;if(i<o[0]){switch(r){case e.setup:return void(h.rotation=h.data.rotation);case e.first:let t=h.data.rotation-h.rotation;h.rotation+=(t-360*(16384-(16384.499999999996-t/360|0)))*s}return}if(i>=o[o.length-RotateTimeline.ENTRIES]){let t=o[o.length+RotateTimeline.PREV_ROTATION];switch(r){case e.setup:h.rotation=h.data.rotation+t*s;break;case e.first:case e.replace:t+=h.data.rotation-h.rotation,t-=360*(16384-(16384.499999999996-t/360|0));case e.add:h.rotation+=t*s}return}let d=Animation.binarySearch(o,i,RotateTimeline.ENTRIES),u=o[d+RotateTimeline.PREV_ROTATION],c=o[d],m=this.getCurvePercent((d>>1)-1,1-(i-c)/(o[d+RotateTimeline.PREV_TIME]-c)),f=o[d+RotateTimeline.ROTATION]-u;switch(f=u+(f-360*(16384-(16384.499999999996-f/360|0)))*m,r){case e.setup:h.rotation=h.data.rotation+(f-360*(16384-(16384.499999999996-f/360|0)))*s;break;case e.first:case e.replace:f+=h.data.rotation-h.rotation;case e.add:h.rotation+=(f-360*(16384-(16384.499999999996-f/360|0)))*s}}}RotateTimeline.ENTRIES=2,RotateTimeline.PREV_TIME=-2,RotateTimeline.PREV_ROTATION=-1,RotateTimeline.ROTATION=1,t.RotateTimeline=RotateTimeline;class TranslateTimeline extends CurveTimeline{constructor(e){super(e),this.frames=t.Utils.newFloatArray(e*TranslateTimeline.ENTRIES)}getPropertyId(){return(i.translate<<24)+this.boneIndex}setFrame(t,e,n,i){t*=TranslateTimeline.ENTRIES,this.frames[t]=e,this.frames[t+TranslateTimeline.X]=n,this.frames[t+TranslateTimeline.Y]=i}apply(t,n,i,a,s,r,l){let o=this.frames,h=t.bones[this.boneIndex];if(!h.active)return;if(i<o[0]){switch(r){case e.setup:return h.x=h.data.x,void(h.y=h.data.y);case e.first:h.x+=(h.data.x-h.x)*s,h.y+=(h.data.y-h.y)*s}return}let d=0,u=0;if(i>=o[o.length-TranslateTimeline.ENTRIES])d=o[o.length+TranslateTimeline.PREV_X],u=o[o.length+TranslateTimeline.PREV_Y];else{let t=Animation.binarySearch(o,i,TranslateTimeline.ENTRIES);d=o[t+TranslateTimeline.PREV_X],u=o[t+TranslateTimeline.PREV_Y];let e=o[t],n=this.getCurvePercent(t/TranslateTimeline.ENTRIES-1,1-(i-e)/(o[t+TranslateTimeline.PREV_TIME]-e));d+=(o[t+TranslateTimeline.X]-d)*n,u+=(o[t+TranslateTimeline.Y]-u)*n}switch(r){case e.setup:h.x=h.data.x+d*s,h.y=h.data.y+u*s;break;case e.first:case e.replace:h.x+=(h.data.x+d-h.x)*s,h.y+=(h.data.y+u-h.y)*s;break;case e.add:h.x+=d*s,h.y+=u*s}}}TranslateTimeline.ENTRIES=3,TranslateTimeline.PREV_TIME=-3,TranslateTimeline.PREV_X=-2,TranslateTimeline.PREV_Y=-1,TranslateTimeline.X=1,TranslateTimeline.Y=2,t.TranslateTimeline=TranslateTimeline;class ScaleTimeline extends TranslateTimeline{constructor(t){super(t)}getPropertyId(){return(i.scale<<24)+this.boneIndex}apply(i,a,s,r,l,o,h){let d=this.frames,u=i.bones[this.boneIndex];if(!u.active)return;if(s<d[0]){switch(o){case e.setup:return u.scaleX=u.data.scaleX,void(u.scaleY=u.data.scaleY);case e.first:u.scaleX+=(u.data.scaleX-u.scaleX)*l,u.scaleY+=(u.data.scaleY-u.scaleY)*l}return}let c=0,m=0;if(s>=d[d.length-ScaleTimeline.ENTRIES])c=d[d.length+ScaleTimeline.PREV_X]*u.data.scaleX,m=d[d.length+ScaleTimeline.PREV_Y]*u.data.scaleY;else{let t=Animation.binarySearch(d,s,ScaleTimeline.ENTRIES);c=d[t+ScaleTimeline.PREV_X],m=d[t+ScaleTimeline.PREV_Y];let e=d[t],n=this.getCurvePercent(t/ScaleTimeline.ENTRIES-1,1-(s-e)/(d[t+ScaleTimeline.PREV_TIME]-e));c=(c+(d[t+ScaleTimeline.X]-c)*n)*u.data.scaleX,m=(m+(d[t+ScaleTimeline.Y]-m)*n)*u.data.scaleY}if(1==l)o==e.add?(u.scaleX+=c-u.data.scaleX,u.scaleY+=m-u.data.scaleY):(u.scaleX=c,u.scaleY=m);else{let i=0,a=0;if(h==n.mixOut)switch(o){case e.setup:i=u.data.scaleX,a=u.data.scaleY,u.scaleX=i+(Math.abs(c)*t.MathUtils.signum(i)-i)*l,u.scaleY=a+(Math.abs(m)*t.MathUtils.signum(a)-a)*l;break;case e.first:case e.replace:i=u.scaleX,a=u.scaleY,u.scaleX=i+(Math.abs(c)*t.MathUtils.signum(i)-i)*l,u.scaleY=a+(Math.abs(m)*t.MathUtils.signum(a)-a)*l;break;case e.add:i=u.scaleX,a=u.scaleY,u.scaleX=i+(Math.abs(c)*t.MathUtils.signum(i)-u.data.scaleX)*l,u.scaleY=a+(Math.abs(m)*t.MathUtils.signum(a)-u.data.scaleY)*l}else switch(o){case e.setup:i=Math.abs(u.data.scaleX)*t.MathUtils.signum(c),a=Math.abs(u.data.scaleY)*t.MathUtils.signum(m),u.scaleX=i+(c-i)*l,u.scaleY=a+(m-a)*l;break;case e.first:case e.replace:i=Math.abs(u.scaleX)*t.MathUtils.signum(c),a=Math.abs(u.scaleY)*t.MathUtils.signum(m),u.scaleX=i+(c-i)*l,u.scaleY=a+(m-a)*l;break;case e.add:i=t.MathUtils.signum(c),a=t.MathUtils.signum(m),u.scaleX=Math.abs(u.scaleX)*i+(c-Math.abs(u.data.scaleX)*i)*l,u.scaleY=Math.abs(u.scaleY)*a+(m-Math.abs(u.data.scaleY)*a)*l}}}}t.ScaleTimeline=ScaleTimeline;class ShearTimeline extends TranslateTimeline{constructor(t){super(t)}getPropertyId(){return(i.shear<<24)+this.boneIndex}apply(t,n,i,a,s,r,l){let o=this.frames,h=t.bones[this.boneIndex];if(!h.active)return;if(i<o[0]){switch(r){case e.setup:return h.shearX=h.data.shearX,void(h.shearY=h.data.shearY);case e.first:h.shearX+=(h.data.shearX-h.shearX)*s,h.shearY+=(h.data.shearY-h.shearY)*s}return}let d=0,u=0;if(i>=o[o.length-ShearTimeline.ENTRIES])d=o[o.length+ShearTimeline.PREV_X],u=o[o.length+ShearTimeline.PREV_Y];else{let t=Animation.binarySearch(o,i,ShearTimeline.ENTRIES);d=o[t+ShearTimeline.PREV_X],u=o[t+ShearTimeline.PREV_Y];let e=o[t],n=this.getCurvePercent(t/ShearTimeline.ENTRIES-1,1-(i-e)/(o[t+ShearTimeline.PREV_TIME]-e));d+=(o[t+ShearTimeline.X]-d)*n,u+=(o[t+ShearTimeline.Y]-u)*n}switch(r){case e.setup:h.shearX=h.data.shearX+d*s,h.shearY=h.data.shearY+u*s;break;case e.first:case e.replace:h.shearX+=(h.data.shearX+d-h.shearX)*s,h.shearY+=(h.data.shearY+u-h.shearY)*s;break;case e.add:h.shearX+=d*s,h.shearY+=u*s}}}t.ShearTimeline=ShearTimeline;class ColorTimeline extends CurveTimeline{constructor(e){super(e),this.frames=t.Utils.newFloatArray(e*ColorTimeline.ENTRIES)}getPropertyId(){return(i.color<<24)+this.slotIndex}setFrame(t,e,n,i,a,s){t*=ColorTimeline.ENTRIES,this.frames[t]=e,this.frames[t+ColorTimeline.R]=n,this.frames[t+ColorTimeline.G]=i,this.frames[t+ColorTimeline.B]=a,this.frames[t+ColorTimeline.A]=s}apply(t,n,i,a,s,r,l){let o=t.slots[this.slotIndex];if(!o.bone.active)return;let h=this.frames;if(i<h[0]){switch(r){case e.setup:return void o.color.setFromColor(o.data.color);case e.first:let t=o.color,n=o.data.color;t.add((n.r-t.r)*s,(n.g-t.g)*s,(n.b-t.b)*s,(n.a-t.a)*s)}return}let d=0,u=0,c=0,m=0;if(i>=h[h.length-ColorTimeline.ENTRIES]){let t=h.length;d=h[t+ColorTimeline.PREV_R],u=h[t+ColorTimeline.PREV_G],c=h[t+ColorTimeline.PREV_B],m=h[t+ColorTimeline.PREV_A]}else{let t=Animation.binarySearch(h,i,ColorTimeline.ENTRIES);d=h[t+ColorTimeline.PREV_R],u=h[t+ColorTimeline.PREV_G],c=h[t+ColorTimeline.PREV_B],m=h[t+ColorTimeline.PREV_A];let e=h[t],n=this.getCurvePercent(t/ColorTimeline.ENTRIES-1,1-(i-e)/(h[t+ColorTimeline.PREV_TIME]-e));d+=(h[t+ColorTimeline.R]-d)*n,u+=(h[t+ColorTimeline.G]-u)*n,c+=(h[t+ColorTimeline.B]-c)*n,m+=(h[t+ColorTimeline.A]-m)*n}if(1==s)o.color.set(d,u,c,m);else{let t=o.color;r==e.setup&&t.setFromColor(o.data.color),t.add((d-t.r)*s,(u-t.g)*s,(c-t.b)*s,(m-t.a)*s)}}}ColorTimeline.ENTRIES=5,ColorTimeline.PREV_TIME=-5,ColorTimeline.PREV_R=-4,ColorTimeline.PREV_G=-3,ColorTimeline.PREV_B=-2,ColorTimeline.PREV_A=-1,ColorTimeline.R=1,ColorTimeline.G=2,ColorTimeline.B=3,ColorTimeline.A=4,t.ColorTimeline=ColorTimeline;class TwoColorTimeline extends CurveTimeline{constructor(e){super(e),this.frames=t.Utils.newFloatArray(e*TwoColorTimeline.ENTRIES)}getPropertyId(){return(i.twoColor<<24)+this.slotIndex}setFrame(t,e,n,i,a,s,r,l,o){t*=TwoColorTimeline.ENTRIES,this.frames[t]=e,this.frames[t+TwoColorTimeline.R]=n,this.frames[t+TwoColorTimeline.G]=i,this.frames[t+TwoColorTimeline.B]=a,this.frames[t+TwoColorTimeline.A]=s,this.frames[t+TwoColorTimeline.R2]=r,this.frames[t+TwoColorTimeline.G2]=l,this.frames[t+TwoColorTimeline.B2]=o}apply(t,n,i,a,s,r,l){let o=t.slots[this.slotIndex];if(!o.bone.active)return;let h=this.frames;if(i<h[0]){switch(r){case e.setup:return o.color.setFromColor(o.data.color),void o.darkColor.setFromColor(o.data.darkColor);case e.first:let t=o.color,n=o.darkColor,i=o.data.color,a=o.data.darkColor;t.add((i.r-t.r)*s,(i.g-t.g)*s,(i.b-t.b)*s,(i.a-t.a)*s),n.add((a.r-n.r)*s,(a.g-n.g)*s,(a.b-n.b)*s,0)}return}let d=0,u=0,c=0,m=0,f=0,g=0,p=0;if(i>=h[h.length-TwoColorTimeline.ENTRIES]){let t=h.length;d=h[t+TwoColorTimeline.PREV_R],u=h[t+TwoColorTimeline.PREV_G],c=h[t+TwoColorTimeline.PREV_B],m=h[t+TwoColorTimeline.PREV_A],f=h[t+TwoColorTimeline.PREV_R2],g=h[t+TwoColorTimeline.PREV_G2],p=h[t+TwoColorTimeline.PREV_B2]}else{let t=Animation.binarySearch(h,i,TwoColorTimeline.ENTRIES);d=h[t+TwoColorTimeline.PREV_R],u=h[t+TwoColorTimeline.PREV_G],c=h[t+TwoColorTimeline.PREV_B],m=h[t+TwoColorTimeline.PREV_A],f=h[t+TwoColorTimeline.PREV_R2],g=h[t+TwoColorTimeline.PREV_G2],p=h[t+TwoColorTimeline.PREV_B2];let e=h[t],n=this.getCurvePercent(t/TwoColorTimeline.ENTRIES-1,1-(i-e)/(h[t+TwoColorTimeline.PREV_TIME]-e));d+=(h[t+TwoColorTimeline.R]-d)*n,u+=(h[t+TwoColorTimeline.G]-u)*n,c+=(h[t+TwoColorTimeline.B]-c)*n,m+=(h[t+TwoColorTimeline.A]-m)*n,f+=(h[t+TwoColorTimeline.R2]-f)*n,g+=(h[t+TwoColorTimeline.G2]-g)*n,p+=(h[t+TwoColorTimeline.B2]-p)*n}if(1==s)o.color.set(d,u,c,m),o.darkColor.set(f,g,p,1);else{let t=o.color,n=o.darkColor;r==e.setup&&(t.setFromColor(o.data.color),n.setFromColor(o.data.darkColor)),t.add((d-t.r)*s,(u-t.g)*s,(c-t.b)*s,(m-t.a)*s),n.add((f-n.r)*s,(g-n.g)*s,(p-n.b)*s,0)}}}TwoColorTimeline.ENTRIES=8,TwoColorTimeline.PREV_TIME=-8,TwoColorTimeline.PREV_R=-7,TwoColorTimeline.PREV_G=-6,TwoColorTimeline.PREV_B=-5,TwoColorTimeline.PREV_A=-4,TwoColorTimeline.PREV_R2=-3,TwoColorTimeline.PREV_G2=-2,TwoColorTimeline.PREV_B2=-1,TwoColorTimeline.R=1,TwoColorTimeline.G=2,TwoColorTimeline.B=3,TwoColorTimeline.A=4,TwoColorTimeline.R2=5,TwoColorTimeline.G2=6,TwoColorTimeline.B2=7,t.TwoColorTimeline=TwoColorTimeline;t.AttachmentTimeline=class{constructor(e){this.frames=t.Utils.newFloatArray(e),this.attachmentNames=new Array(e)}getPropertyId(){return(i.attachment<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.attachmentNames[t]=n}apply(t,i,a,s,r,l,o){let h=t.slots[this.slotIndex];if(!h.bone.active)return;if(o==n.mixOut)return void(l==e.setup&&this.setAttachment(t,h,h.data.attachmentName));let d=this.frames;if(a<d[0])return void(l!=e.setup&&l!=e.first||this.setAttachment(t,h,h.data.attachmentName));let u=0;u=a>=d[d.length-1]?d.length-1:Animation.binarySearch(d,a,1)-1;let c=this.attachmentNames[u];t.slots[this.slotIndex].setAttachment(null==c?null:t.getAttachment(this.slotIndex,c))}setAttachment(t,e,n){e.setAttachment(null==n?null:t.getAttachment(this.slotIndex,n))}};let a=null;t.DeformTimeline=class extends CurveTimeline{constructor(e){super(e),this.frames=t.Utils.newFloatArray(e),this.frameVertices=new Array(e),null==a&&(a=t.Utils.newFloatArray(64))}getPropertyId(){return(i.deform<<27)+ +this.attachment.id+this.slotIndex}setFrame(t,e,n){this.frames[t]=e,this.frameVertices[t]=n}apply(n,i,a,s,r,l,o){let h=n.slots[this.slotIndex];if(!h.bone.active)return;let d=h.getAttachment();if(!(d instanceof t.VertexAttachment)||d.deformAttachment!=this.attachment)return;let u=h.deform;0==u.length&&(l=e.setup);let c=this.frameVertices,m=c[0].length,f=this.frames;if(a<f[0]){let n=d;switch(l){case e.setup:return void(u.length=0);case e.first:if(1==r){u.length=0;break}let i=t.Utils.setArraySize(u,m);if(null==n.bones){let t=n.vertices;for(var g=0;g<m;g++)i[g]+=(t[g]-i[g])*r}else{r=1-r;for(g=0;g<m;g++)i[g]*=r}}return}let p=t.Utils.setArraySize(u,m);if(a>=f[f.length-1]){let n=c[f.length-1];if(1==r)if(l==e.add){let t=d;if(null==t.bones){let e=t.vertices;for(let t=0;t<m;t++)p[t]+=n[t]-e[t]}else for(let t=0;t<m;t++)p[t]+=n[t]}else t.Utils.arrayCopy(n,0,p,0,m);else switch(l){case e.setup:{let t=d;if(null==t.bones){let e=t.vertices;for(let t=0;t<m;t++){let i=e[t];p[t]=i+(n[t]-i)*r}}else for(let t=0;t<m;t++)p[t]=n[t]*r;break}case e.first:case e.replace:for(let t=0;t<m;t++)p[t]+=(n[t]-p[t])*r;break;case e.add:let t=d;if(null==t.bones){let e=t.vertices;for(let t=0;t<m;t++)p[t]+=(n[t]-e[t])*r}else for(let t=0;t<m;t++)p[t]+=n[t]*r}return}let T=Animation.binarySearch(f,a),w=c[T-1],C=c[T],M=f[T],x=this.getCurvePercent(T-1,1-(a-M)/(f[T-1]-M));if(1==r)if(l==e.add){let t=d;if(null==t.bones){let e=t.vertices;for(let t=0;t<m;t++){let n=w[t];p[t]+=n+(C[t]-n)*x-e[t]}}else for(let t=0;t<m;t++){let e=w[t];p[t]+=e+(C[t]-e)*x}}else for(let t=0;t<m;t++){let e=w[t];p[t]=e+(C[t]-e)*x}else switch(l){case e.setup:{let t=d;if(null==t.bones){let e=t.vertices;for(let t=0;t<m;t++){let n=w[t],i=e[t];p[t]=i+(n+(C[t]-n)*x-i)*r}}else for(let t=0;t<m;t++){let e=w[t];p[t]=(e+(C[t]-e)*x)*r}break}case e.first:case e.replace:for(let t=0;t<m;t++){let e=w[t];p[t]+=(e+(C[t]-e)*x-p[t])*r}break;case e.add:let t=d;if(null==t.bones){let e=t.vertices;for(let t=0;t<m;t++){let n=w[t];p[t]+=(n+(C[t]-n)*x-e[t])*r}}else for(let t=0;t<m;t++){let e=w[t];p[t]+=(e+(C[t]-e)*x)*r}}}};t.EventTimeline=class{constructor(e){this.frames=t.Utils.newFloatArray(e),this.events=new Array(e)}getPropertyId(){return i.event<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,n,i,a,s,r){if(null==i)return;let l=this.frames,o=this.frames.length;if(e>n)this.apply(t,e,Number.MAX_VALUE,i,a,s,r),e=-1;else if(e>=l[o-1])return;if(n<l[0])return;let h=0;if(e<l[0])h=0;else{h=Animation.binarySearch(l,e);let t=l[h];for(;h>0&&l[h-1]==t;)h--}for(;h<o&&n>=l[h];h++)i.push(this.events[h])}};t.DrawOrderTimeline=class{constructor(e){this.frames=t.Utils.newFloatArray(e),this.drawOrders=new Array(e)}getPropertyId(){return i.drawOrder<<24}getFrameCount(){return this.frames.length}setFrame(t,e,n){this.frames[t]=e,this.drawOrders[t]=n}apply(i,a,s,r,l,o,h){let d=i.drawOrder,u=i.slots;if(h==n.mixOut)return void(o==e.setup&&t.Utils.arrayCopy(i.slots,0,i.drawOrder,0,i.slots.length));let c=this.frames;if(s<c[0])return void(o!=e.setup&&o!=e.first||t.Utils.arrayCopy(i.slots,0,i.drawOrder,0,i.slots.length));let m=0;m=s>=c[c.length-1]?c.length-1:Animation.binarySearch(c,s)-1;let f=this.drawOrders[m];if(null==f)t.Utils.arrayCopy(u,0,d,0,u.length);else for(let t=0,e=f.length;t<e;t++)d[t]=u[f[t]]}};class IkConstraintTimeline extends CurveTimeline{constructor(e){super(e),this.frames=t.Utils.newFloatArray(e*IkConstraintTimeline.ENTRIES)}getPropertyId(){return(i.ikConstraint<<24)+this.ikConstraintIndex}setFrame(t,e,n,i,a,s,r){t*=IkConstraintTimeline.ENTRIES,this.frames[t]=e,this.frames[t+IkConstraintTimeline.MIX]=n,this.frames[t+IkConstraintTimeline.SOFTNESS]=i,this.frames[t+IkConstraintTimeline.BEND_DIRECTION]=a,this.frames[t+IkConstraintTimeline.COMPRESS]=s?1:0,this.frames[t+IkConstraintTimeline.STRETCH]=r?1:0}apply(t,i,a,s,r,l,o){let h=this.frames,d=t.ikConstraints[this.ikConstraintIndex];if(!d.active)return;if(a<h[0]){switch(l){case e.setup:return d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,void(d.stretch=d.data.stretch);case e.first:d.mix+=(d.data.mix-d.mix)*r,d.softness+=(d.data.softness-d.softness)*r,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}return}if(a>=h[h.length-IkConstraintTimeline.ENTRIES])return void(l==e.setup?(d.mix=d.data.mix+(h[h.length+IkConstraintTimeline.PREV_MIX]-d.data.mix)*r,d.softness=d.data.softness+(h[h.length+IkConstraintTimeline.PREV_SOFTNESS]-d.data.softness)*r,o==n.mixOut?(d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch):(d.bendDirection=h[h.length+IkConstraintTimeline.PREV_BEND_DIRECTION],d.compress=0!=h[h.length+IkConstraintTimeline.PREV_COMPRESS],d.stretch=0!=h[h.length+IkConstraintTimeline.PREV_STRETCH])):(d.mix+=(h[h.length+IkConstraintTimeline.PREV_MIX]-d.mix)*r,d.softness+=(h[h.length+IkConstraintTimeline.PREV_SOFTNESS]-d.softness)*r,o==n.mixIn&&(d.bendDirection=h[h.length+IkConstraintTimeline.PREV_BEND_DIRECTION],d.compress=0!=h[h.length+IkConstraintTimeline.PREV_COMPRESS],d.stretch=0!=h[h.length+IkConstraintTimeline.PREV_STRETCH])));let u=Animation.binarySearch(h,a,IkConstraintTimeline.ENTRIES),c=h[u+IkConstraintTimeline.PREV_MIX],m=h[u+IkConstraintTimeline.PREV_SOFTNESS],f=h[u],g=this.getCurvePercent(u/IkConstraintTimeline.ENTRIES-1,1-(a-f)/(h[u+IkConstraintTimeline.PREV_TIME]-f));l==e.setup?(d.mix=d.data.mix+(c+(h[u+IkConstraintTimeline.MIX]-c)*g-d.data.mix)*r,d.softness=d.data.softness+(m+(h[u+IkConstraintTimeline.SOFTNESS]-m)*g-d.data.softness)*r,o==n.mixOut?(d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch):(d.bendDirection=h[u+IkConstraintTimeline.PREV_BEND_DIRECTION],d.compress=0!=h[u+IkConstraintTimeline.PREV_COMPRESS],d.stretch=0!=h[u+IkConstraintTimeline.PREV_STRETCH])):(d.mix+=(c+(h[u+IkConstraintTimeline.MIX]-c)*g-d.mix)*r,d.softness+=(m+(h[u+IkConstraintTimeline.SOFTNESS]-m)*g-d.softness)*r,o==n.mixIn&&(d.bendDirection=h[u+IkConstraintTimeline.PREV_BEND_DIRECTION],d.compress=0!=h[u+IkConstraintTimeline.PREV_COMPRESS],d.stretch=0!=h[u+IkConstraintTimeline.PREV_STRETCH]))}}IkConstraintTimeline.ENTRIES=6,IkConstraintTimeline.PREV_TIME=-6,IkConstraintTimeline.PREV_MIX=-5,IkConstraintTimeline.PREV_SOFTNESS=-4,IkConstraintTimeline.PREV_BEND_DIRECTION=-3,IkConstraintTimeline.PREV_COMPRESS=-2,IkConstraintTimeline.PREV_STRETCH=-1,IkConstraintTimeline.MIX=1,IkConstraintTimeline.SOFTNESS=2,IkConstraintTimeline.BEND_DIRECTION=3,IkConstraintTimeline.COMPRESS=4,IkConstraintTimeline.STRETCH=5,t.IkConstraintTimeline=IkConstraintTimeline;class TransformConstraintTimeline extends CurveTimeline{constructor(e){super(e),this.frames=t.Utils.newFloatArray(e*TransformConstraintTimeline.ENTRIES)}getPropertyId(){return(i.transformConstraint<<24)+this.transformConstraintIndex}setFrame(t,e,n,i,a,s){t*=TransformConstraintTimeline.ENTRIES,this.frames[t]=e,this.frames[t+TransformConstraintTimeline.ROTATE]=n,this.frames[t+TransformConstraintTimeline.TRANSLATE]=i,this.frames[t+TransformConstraintTimeline.SCALE]=a,this.frames[t+TransformConstraintTimeline.SHEAR]=s}apply(t,n,i,a,s,r,l){let o=this.frames,h=t.transformConstraints[this.transformConstraintIndex];if(!h.active)return;if(i<o[0]){let t=h.data;switch(r){case e.setup:return h.rotateMix=t.rotateMix,h.translateMix=t.translateMix,h.scaleMix=t.scaleMix,void(h.shearMix=t.shearMix);case e.first:h.rotateMix+=(t.rotateMix-h.rotateMix)*s,h.translateMix+=(t.translateMix-h.translateMix)*s,h.scaleMix+=(t.scaleMix-h.scaleMix)*s,h.shearMix+=(t.shearMix-h.shearMix)*s}return}let d=0,u=0,c=0,m=0;if(i>=o[o.length-TransformConstraintTimeline.ENTRIES]){let t=o.length;d=o[t+TransformConstraintTimeline.PREV_ROTATE],u=o[t+TransformConstraintTimeline.PREV_TRANSLATE],c=o[t+TransformConstraintTimeline.PREV_SCALE],m=o[t+TransformConstraintTimeline.PREV_SHEAR]}else{let t=Animation.binarySearch(o,i,TransformConstraintTimeline.ENTRIES);d=o[t+TransformConstraintTimeline.PREV_ROTATE],u=o[t+TransformConstraintTimeline.PREV_TRANSLATE],c=o[t+TransformConstraintTimeline.PREV_SCALE],m=o[t+TransformConstraintTimeline.PREV_SHEAR];let e=o[t],n=this.getCurvePercent(t/TransformConstraintTimeline.ENTRIES-1,1-(i-e)/(o[t+TransformConstraintTimeline.PREV_TIME]-e));d+=(o[t+TransformConstraintTimeline.ROTATE]-d)*n,u+=(o[t+TransformConstraintTimeline.TRANSLATE]-u)*n,c+=(o[t+TransformConstraintTimeline.SCALE]-c)*n,m+=(o[t+TransformConstraintTimeline.SHEAR]-m)*n}if(r==e.setup){let t=h.data;h.rotateMix=t.rotateMix+(d-t.rotateMix)*s,h.translateMix=t.translateMix+(u-t.translateMix)*s,h.scaleMix=t.scaleMix+(c-t.scaleMix)*s,h.shearMix=t.shearMix+(m-t.shearMix)*s}else h.rotateMix+=(d-h.rotateMix)*s,h.translateMix+=(u-h.translateMix)*s,h.scaleMix+=(c-h.scaleMix)*s,h.shearMix+=(m-h.shearMix)*s}}TransformConstraintTimeline.ENTRIES=5,TransformConstraintTimeline.PREV_TIME=-5,TransformConstraintTimeline.PREV_ROTATE=-4,TransformConstraintTimeline.PREV_TRANSLATE=-3,TransformConstraintTimeline.PREV_SCALE=-2,TransformConstraintTimeline.PREV_SHEAR=-1,TransformConstraintTimeline.ROTATE=1,TransformConstraintTimeline.TRANSLATE=2,TransformConstraintTimeline.SCALE=3,TransformConstraintTimeline.SHEAR=4,t.TransformConstraintTimeline=TransformConstraintTimeline;class PathConstraintPositionTimeline extends CurveTimeline{constructor(e){super(e),this.frames=t.Utils.newFloatArray(e*PathConstraintPositionTimeline.ENTRIES)}getPropertyId(){return(i.pathConstraintPosition<<24)+this.pathConstraintIndex}setFrame(t,e,n){t*=PathConstraintPositionTimeline.ENTRIES,this.frames[t]=e,this.frames[t+PathConstraintPositionTimeline.VALUE]=n}apply(t,n,i,a,s,r,l){let o=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(!h.active)return;if(i<o[0]){switch(r){case e.setup:return void(h.position=h.data.position);case e.first:h.position+=(h.data.position-h.position)*s}return}let d=0;if(i>=o[o.length-PathConstraintPositionTimeline.ENTRIES])d=o[o.length+PathConstraintPositionTimeline.PREV_VALUE];else{let t=Animation.binarySearch(o,i,PathConstraintPositionTimeline.ENTRIES);d=o[t+PathConstraintPositionTimeline.PREV_VALUE];let e=o[t],n=this.getCurvePercent(t/PathConstraintPositionTimeline.ENTRIES-1,1-(i-e)/(o[t+PathConstraintPositionTimeline.PREV_TIME]-e));d+=(o[t+PathConstraintPositionTimeline.VALUE]-d)*n}r==e.setup?h.position=h.data.position+(d-h.data.position)*s:h.position+=(d-h.position)*s}}PathConstraintPositionTimeline.ENTRIES=2,PathConstraintPositionTimeline.PREV_TIME=-2,PathConstraintPositionTimeline.PREV_VALUE=-1,PathConstraintPositionTimeline.VALUE=1,t.PathConstraintPositionTimeline=PathConstraintPositionTimeline;class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline{constructor(t){super(t)}getPropertyId(){return(i.pathConstraintSpacing<<24)+this.pathConstraintIndex}apply(t,n,i,a,s,r,l){let o=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(!h.active)return;if(i<o[0]){switch(r){case e.setup:return void(h.spacing=h.data.spacing);case e.first:h.spacing+=(h.data.spacing-h.spacing)*s}return}let d=0;if(i>=o[o.length-PathConstraintSpacingTimeline.ENTRIES])d=o[o.length+PathConstraintSpacingTimeline.PREV_VALUE];else{let t=Animation.binarySearch(o,i,PathConstraintSpacingTimeline.ENTRIES);d=o[t+PathConstraintSpacingTimeline.PREV_VALUE];let e=o[t],n=this.getCurvePercent(t/PathConstraintSpacingTimeline.ENTRIES-1,1-(i-e)/(o[t+PathConstraintSpacingTimeline.PREV_TIME]-e));d+=(o[t+PathConstraintSpacingTimeline.VALUE]-d)*n}r==e.setup?h.spacing=h.data.spacing+(d-h.data.spacing)*s:h.spacing+=(d-h.spacing)*s}}t.PathConstraintSpacingTimeline=PathConstraintSpacingTimeline;class PathConstraintMixTimeline extends CurveTimeline{constructor(e){super(e),this.frames=t.Utils.newFloatArray(e*PathConstraintMixTimeline.ENTRIES)}getPropertyId(){return(i.pathConstraintMix<<24)+this.pathConstraintIndex}setFrame(t,e,n,i){t*=PathConstraintMixTimeline.ENTRIES,this.frames[t]=e,this.frames[t+PathConstraintMixTimeline.ROTATE]=n,this.frames[t+PathConstraintMixTimeline.TRANSLATE]=i}apply(t,n,i,a,s,r,l){let o=this.frames,h=t.pathConstraints[this.pathConstraintIndex];if(!h.active)return;if(i<o[0]){switch(r){case e.setup:return h.rotateMix=h.data.rotateMix,void(h.translateMix=h.data.translateMix);case e.first:h.rotateMix+=(h.data.rotateMix-h.rotateMix)*s,h.translateMix+=(h.data.translateMix-h.translateMix)*s}return}let d=0,u=0;if(i>=o[o.length-PathConstraintMixTimeline.ENTRIES])d=o[o.length+PathConstraintMixTimeline.PREV_ROTATE],u=o[o.length+PathConstraintMixTimeline.PREV_TRANSLATE];else{let t=Animation.binarySearch(o,i,PathConstraintMixTimeline.ENTRIES);d=o[t+PathConstraintMixTimeline.PREV_ROTATE],u=o[t+PathConstraintMixTimeline.PREV_TRANSLATE];let e=o[t],n=this.getCurvePercent(t/PathConstraintMixTimeline.ENTRIES-1,1-(i-e)/(o[t+PathConstraintMixTimeline.PREV_TIME]-e));d+=(o[t+PathConstraintMixTimeline.ROTATE]-d)*n,u+=(o[t+PathConstraintMixTimeline.TRANSLATE]-u)*n}r==e.setup?(h.rotateMix=h.data.rotateMix+(d-h.data.rotateMix)*s,h.translateMix=h.data.translateMix+(u-h.data.translateMix)*s):(h.rotateMix+=(d-h.rotateMix)*s,h.translateMix+=(u-h.translateMix)*s)}}PathConstraintMixTimeline.ENTRIES=3,PathConstraintMixTimeline.PREV_TIME=-3,PathConstraintMixTimeline.PREV_ROTATE=-2,PathConstraintMixTimeline.PREV_TRANSLATE=-1,PathConstraintMixTimeline.ROTATE=1,PathConstraintMixTimeline.TRANSLATE=2,t.PathConstraintMixTimeline=PathConstraintMixTimeline}(spine||(spine={})),function(t){class AnimationState{constructor(e){this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new EventQueue(this),this.propertyIDs=new t.IntSet,this.animationsChanged=!1,this.trackEntryPool=new t.Pool((()=>new TrackEntry)),this.data=e}update(t){t*=this.timeScale;let e=this.tracks;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(null==i)continue;i.animationLast=i.nextAnimationLast,i.trackLast=i.nextTrackLast;let a=t*i.timeScale;if(i.delay>0){if(i.delay-=a,i.delay>0)continue;a=-i.delay,i.delay=0}let s=i.next;if(null!=s){let e=i.trackLast-s.delay;if(e>=0){for(s.delay=0,s.trackTime+=0==i.timeScale?0:(e/i.timeScale+t)*s.timeScale,i.trackTime+=a,this.setCurrent(n,s,!0);null!=s.mixingFrom;)s.mixTime+=t,s=s.mixingFrom;continue}}else if(i.trackLast>=i.trackEnd&&null==i.mixingFrom){e[n]=null,this.queue.end(i),this.disposeNext(i);continue}if(null!=i.mixingFrom&&this.updateMixingFrom(i,t)){let t=i.mixingFrom;for(i.mixingFrom=null,null!=t&&(t.mixingTo=null);null!=t;)this.queue.end(t),t=t.mixingFrom}i.trackTime+=a}this.queue.drain()}updateMixingFrom(t,e){let n=t.mixingFrom;if(null==n)return!0;let i=this.updateMixingFrom(n,e);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?(0!=n.totalAlpha&&0!=t.mixDuration||(t.mixingFrom=n.mixingFrom,null!=n.mixingFrom&&(n.mixingFrom.mixingTo=t),t.interruptAlpha=n.interruptAlpha,this.queue.end(n)),i):(n.trackTime+=e*n.timeScale,t.mixTime+=e,!1)}apply(e){if(null==e)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();let n=this.events,i=this.tracks,a=!1;for(let r=0,l=i.length;r<l;r++){let l=i[r];if(null==l||l.delay>0)continue;a=!0;let o=0==r?t.MixBlend.first:l.mixBlend,h=l.alpha;null!=l.mixingFrom?h*=this.applyMixingFrom(l,e,o):l.trackTime>=l.trackEnd&&null==l.next&&(h=0);let d=l.animationLast,u=l.getAnimationTime(),c=l.animation.timelines.length,m=l.animation.timelines;if(0==r&&1==h||o==t.MixBlend.add)for(let i=0;i<c;i++){t.Utils.webkit602BugfixHelper(h,o);var s=m[i];s instanceof t.AttachmentTimeline?this.applyAttachmentTimeline(s,e,u,o,!0):s.apply(e,d,u,n,h,o,t.MixDirection.mixIn)}else{let i=l.timelineMode,a=0==l.timelinesRotation.length;a&&t.Utils.setArraySize(l.timelinesRotation,c<<1,null);let s=l.timelinesRotation;for(let r=0;r<c;r++){let l=m[r],c=i[r]==AnimationState.SUBSEQUENT?o:t.MixBlend.setup;l instanceof t.RotateTimeline?this.applyRotateTimeline(l,e,u,h,c,s,r<<1,a):l instanceof t.AttachmentTimeline?this.applyAttachmentTimeline(l,e,u,o,!0):(t.Utils.webkit602BugfixHelper(h,o),l.apply(e,d,u,n,h,c,t.MixDirection.mixIn))}}this.queueEvents(l,u),n.length=0,l.nextAnimationLast=u,l.nextTrackLast=l.trackTime}for(var r=this.unkeyedState+AnimationState.SETUP,l=e.slots,o=0,h=e.slots.length;o<h;o++){var d=l[o];if(d.attachmentState==r){var u=d.data.attachmentName;d.setAttachment(null==u?null:e.getAttachment(d.data.index,u))}}return this.unkeyedState+=2,this.queue.drain(),a}applyMixingFrom(e,n,i){let a=e.mixingFrom;null!=a.mixingFrom&&this.applyMixingFrom(a,n,i);let s=0;0==e.mixDuration?(s=1,i==t.MixBlend.first&&(i=t.MixBlend.setup)):(s=e.mixTime/e.mixDuration,s>1&&(s=1),i!=t.MixBlend.first&&(i=a.mixBlend));let r=s<a.eventThreshold?this.events:null,l=s<a.attachmentThreshold,o=s<a.drawOrderThreshold,h=a.animationLast,d=a.getAnimationTime(),u=a.animation.timelines.length,c=a.animation.timelines,m=a.alpha*e.interruptAlpha,f=m*(1-s);if(i==t.MixBlend.add)for(let e=0;e<u;e++)c[e].apply(n,h,d,r,f,i,t.MixDirection.mixOut);else{let e=a.timelineMode,s=a.timelineHoldMix,g=0==a.timelinesRotation.length;g&&t.Utils.setArraySize(a.timelinesRotation,u<<1,null);let p=a.timelinesRotation;a.totalAlpha=0;for(let T=0;T<u;T++){let u,w=c[T],C=t.MixDirection.mixOut,M=0;switch(e[T]){case AnimationState.SUBSEQUENT:if(!o&&w instanceof t.DrawOrderTimeline)continue;u=i,M=f;break;case AnimationState.FIRST:u=t.MixBlend.setup,M=f;break;case AnimationState.HOLD_SUBSEQUENT:u=i,M=m;break;case AnimationState.HOLD_FIRST:u=t.MixBlend.setup,M=m;break;default:u=t.MixBlend.setup;let e=s[T];M=m*Math.max(0,1-e.mixTime/e.mixDuration)}a.totalAlpha+=M,w instanceof t.RotateTimeline?this.applyRotateTimeline(w,n,d,M,u,p,T<<1,g):w instanceof t.AttachmentTimeline?this.applyAttachmentTimeline(w,n,d,u,l):(t.Utils.webkit602BugfixHelper(M,i),o&&w instanceof t.DrawOrderTimeline&&u==t.MixBlend.setup&&(C=t.MixDirection.mixIn),w.apply(n,h,d,r,M,u,C))}}return e.mixDuration>0&&this.queueEvents(a,d),this.events.length=0,a.nextAnimationLast=d,a.nextTrackLast=a.trackTime,s}applyAttachmentTimeline(e,n,i,a,s){var r=n.slots[e.slotIndex];if(r.bone.active){var l,o=e.frames;if(i<o[0])a!=t.MixBlend.setup&&a!=t.MixBlend.first||this.setAttachment(n,r,r.data.attachmentName,s);else l=i>=o[o.length-1]?o.length-1:t.Animation.binarySearch(o,i)-1,this.setAttachment(n,r,e.attachmentNames[l],s);r.attachmentState<=this.unkeyedState&&(r.attachmentState=this.unkeyedState+AnimationState.SETUP)}}setAttachment(t,e,n,i){e.setAttachment(null==n?null:t.getAttachment(e.data.index,n)),i&&(e.attachmentState=this.unkeyedState+AnimationState.CURRENT)}applyRotateTimeline(e,n,i,a,s,r,l,o){if(o&&(r[l]=0),1==a)return void e.apply(n,0,i,null,1,s,t.MixDirection.mixIn);let h=e,d=h.frames,u=n.bones[h.boneIndex];if(!u.active)return;let c=0,m=0;if(i<d[0])switch(s){case t.MixBlend.setup:u.rotation=u.data.rotation;default:return;case t.MixBlend.first:c=u.rotation,m=u.data.rotation}else if(c=s==t.MixBlend.setup?u.data.rotation:u.rotation,i>=d[d.length-t.RotateTimeline.ENTRIES])m=u.data.rotation+d[d.length+t.RotateTimeline.PREV_ROTATION];else{let e=t.Animation.binarySearch(d,i,t.RotateTimeline.ENTRIES),n=d[e+t.RotateTimeline.PREV_ROTATION],a=d[e],s=h.getCurvePercent((e>>1)-1,1-(i-a)/(d[e+t.RotateTimeline.PREV_TIME]-a));m=d[e+t.RotateTimeline.ROTATION]-n,m-=360*(16384-(16384.499999999996-m/360|0)),m=n+m*s+u.data.rotation,m-=360*(16384-(16384.499999999996-m/360|0))}let f=0,g=m-c;if(g-=360*(16384-(16384.499999999996-g/360|0)),0==g)f=r[l];else{let e=0,n=0;o?(e=0,n=g):(e=r[l],n=r[l+1]);let i=g>0,a=e>=0;t.MathUtils.signum(n)!=t.MathUtils.signum(g)&&Math.abs(n)<=90&&(Math.abs(e)>180&&(e+=360*t.MathUtils.signum(e)),a=i),f=g+e-e%360,a!=i&&(f+=360*t.MathUtils.signum(e)),r[l]=f}r[l+1]=g,c+=f*a,u.rotation=c-360*(16384-(16384.499999999996-c/360|0))}queueEvents(t,e){let n=t.animationStart,i=t.animationEnd,a=i-n,s=t.trackLast%a,r=this.events,l=0,o=r.length;for(;l<o;l++){let e=r[l];if(e.time<s)break;e.time>i||this.queue.event(t,e)}let h=!1;for(h=t.loop?0==a||s>t.trackTime%a:e>=i&&t.animationLast<i,h&&this.queue.complete(t);l<o;l++){r[l].time<n||this.queue.event(t,r[l])}}clearTracks(){let t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,e=this.tracks.length;t<e;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;let e=this.tracks[t];if(null==e)return;this.queue.end(e),this.disposeNext(e);let n=e;for(;;){let t=n.mixingFrom;if(null==t)break;this.queue.end(t),n.mixingFrom=null,n.mixingTo=null,n=t}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,n){let i=this.expandToIndex(t);this.tracks[t]=e,null!=i&&(n&&this.queue.interrupt(i),e.mixingFrom=i,i.mixingTo=e,e.mixTime=0,null!=i.mixingFrom&&i.mixDuration>0&&(e.interruptAlpha*=Math.min(1,i.mixTime/i.mixDuration)),i.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,n){let i=this.data.skeletonData.findAnimation(e);if(null==i)throw new Error("Animation not found: "+e);return this.setAnimationWith(t,i,n)}setAnimationWith(t,e,n){if(null==e)throw new Error("animation cannot be null.");let i=!0,a=this.expandToIndex(t);null!=a&&(-1==a.nextTrackLast?(this.tracks[t]=a.mixingFrom,this.queue.interrupt(a),this.queue.end(a),this.disposeNext(a),a=a.mixingFrom,i=!1):this.disposeNext(a));let s=this.trackEntry(t,e,n,a);return this.setCurrent(t,s,i),this.queue.drain(),s}addAnimation(t,e,n,i){let a=this.data.skeletonData.findAnimation(e);if(null==a)throw new Error("Animation not found: "+e);return this.addAnimationWith(t,a,n,i)}addAnimationWith(t,e,n,i){if(null==e)throw new Error("animation cannot be null.");let a=this.expandToIndex(t);if(null!=a)for(;null!=a.next;)a=a.next;let s=this.trackEntry(t,e,n,a);if(null==a)this.setCurrent(t,s,!0),this.queue.drain();else if(a.next=s,i<=0){let t=a.animationEnd-a.animationStart;0!=t?(a.loop?i+=t*(1+(a.trackTime/t|0)):i+=Math.max(t,a.trackTime),i-=this.data.getMix(a.animation,e)):i=a.trackTime}return s.delay=i,s}setEmptyAnimation(t,e){let n=this.setAnimationWith(t,AnimationState.emptyAnimation,!1);return n.mixDuration=e,n.trackEnd=e,n}addEmptyAnimation(t,e,n){n<=0&&(n-=e);let i=this.addAnimationWith(t,AnimationState.emptyAnimation,!1,n);return i.mixDuration=e,i.trackEnd=e,i}setEmptyAnimations(t){let e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,n=this.tracks.length;e<n;e++){let n=this.tracks[e];null!=n&&this.setEmptyAnimation(n.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(e){return e<this.tracks.length?this.tracks[e]:(t.Utils.ensureArrayCapacity(this.tracks,e+1,null),this.tracks.length=e+1,null)}trackEntry(e,n,i,a){let s=this.trackEntryPool.obtain();return s.trackIndex=e,s.animation=n,s.loop=i,s.holdPrevious=!1,s.eventThreshold=0,s.attachmentThreshold=0,s.drawOrderThreshold=0,s.animationStart=0,s.animationEnd=n.duration,s.animationLast=-1,s.nextAnimationLast=-1,s.delay=0,s.trackTime=0,s.trackLast=-1,s.nextTrackLast=-1,s.trackEnd=Number.MAX_VALUE,s.timeScale=1,s.alpha=1,s.interruptAlpha=1,s.mixTime=0,s.mixDuration=null==a?0:this.data.getMix(a.animation,n),s.mixBlend=t.MixBlend.replace,s}disposeNext(t){let e=t.next;for(;null!=e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let e=0,n=this.tracks.length;e<n;e++){let n=this.tracks[e];if(null!=n){for(;null!=n.mixingFrom;)n=n.mixingFrom;do{null!=n.mixingFrom&&n.mixBlend==t.MixBlend.add||this.computeHold(n),n=n.mixingTo}while(null!=n)}}}computeHold(e){let n=e.mixingTo,i=e.animation.timelines,a=e.animation.timelines.length,s=t.Utils.setArraySize(e.timelineMode,a);e.timelineHoldMix.length=0;let r=t.Utils.setArraySize(e.timelineHoldMix,a),l=this.propertyIDs;if(null!=n&&n.holdPrevious)for(let t=0;t<a;t++)s[t]=l.add(i[t].getPropertyId())?AnimationState.HOLD_FIRST:AnimationState.HOLD_SUBSEQUENT;else t:for(let o=0;o<a;o++){let a=i[o],h=a.getPropertyId();if(l.add(h))if(null==n||a instanceof t.AttachmentTimeline||a instanceof t.DrawOrderTimeline||a instanceof t.EventTimeline||!n.animation.hasTimeline(h))s[o]=AnimationState.FIRST;else{for(let t=n.mixingTo;null!=t;t=t.mixingTo)if(!t.animation.hasTimeline(h)){if(e.mixDuration>0){s[o]=AnimationState.HOLD_MIX,r[o]=t;continue t}break}s[o]=AnimationState.HOLD_FIRST}else s[o]=AnimationState.SUBSEQUENT}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(null==t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){let e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}}AnimationState.emptyAnimation=new t.Animation("<empty>",[],0),AnimationState.SUBSEQUENT=0,AnimationState.FIRST=1,AnimationState.HOLD_SUBSEQUENT=2,AnimationState.HOLD_FIRST=3,AnimationState.HOLD_MIX=4,AnimationState.SETUP=1,AnimationState.CURRENT=2,t.AnimationState=AnimationState;class TrackEntry{constructor(){this.mixBlend=t.MixBlend.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){let t=this.animationEnd-this.animationStart;return 0==t?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}}t.TrackEntry=TrackEntry;class EventQueue{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=t}start(t){this.objects.push(e.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(e.interrupt),this.objects.push(t)}end(t){this.objects.push(e.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(e.dispose),this.objects.push(t)}complete(t){this.objects.push(e.complete),this.objects.push(t)}event(t,n){this.objects.push(e.event),this.objects.push(t),this.objects.push(n)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;let t=this.objects,n=this.animState.listeners;for(let i=0;i<t.length;i+=2){let a=t[i],s=t[i+1];switch(a){case e.start:null!=s.listener&&s.listener.start&&s.listener.start(s);for(let t=0;t<n.length;t++)n[t].start&&n[t].start(s);break;case e.interrupt:null!=s.listener&&s.listener.interrupt&&s.listener.interrupt(s);for(let t=0;t<n.length;t++)n[t].interrupt&&n[t].interrupt(s);break;case e.end:null!=s.listener&&s.listener.end&&s.listener.end(s);for(let t=0;t<n.length;t++)n[t].end&&n[t].end(s);case e.dispose:null!=s.listener&&s.listener.dispose&&s.listener.dispose(s);for(let t=0;t<n.length;t++)n[t].dispose&&n[t].dispose(s);this.animState.trackEntryPool.free(s);break;case e.complete:null!=s.listener&&s.listener.complete&&s.listener.complete(s);for(let t=0;t<n.length;t++)n[t].complete&&n[t].complete(s);break;case e.event:let a=t[2+i++];null!=s.listener&&s.listener.event&&s.listener.event(s,a);for(let t=0;t<n.length;t++)n[t].event&&n[t].event(s,a)}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}let e;t.EventQueue=EventQueue,function(t){t[t.start=0]="start",t[t.interrupt=1]="interrupt",t[t.end=2]="end",t[t.dispose=3]="dispose",t[t.complete=4]="complete",t[t.event=5]="event"}(e=t.EventType||(t.EventType={}));t.AnimationStateAdapter=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}}(spine||(spine={})),function(t){t.AnimationStateData=class{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,null==t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,n){let i=this.skeletonData.findAnimation(t);if(null==i)throw new Error("Animation not found: "+t);let a=this.skeletonData.findAnimation(e);if(null==a)throw new Error("Animation not found: "+e);this.setMixWith(i,a,n)}setMixWith(t,e,n){if(null==t)throw new Error("from cannot be null.");if(null==e)throw new Error("to cannot be null.");let i=t.name+"."+e.name;this.animationToMixTime[i]=n}getMix(t,e){let n=t.name+"."+e.name,i=this.animationToMixTime[n];return void 0===i?this.defaultMix:i}}}(spine||(spine={})),function(t){t.AssetManager=class{constructor(t,e=""){this.assets={},this.errors={},this.toLoad=0,this.loaded=0,this.rawDataUris={},this.textureLoader=t,this.pathPrefix=e}downloadText(t,e,n){let i=new XMLHttpRequest;i.overrideMimeType("text/html"),this.rawDataUris[t]&&(t=this.rawDataUris[t]),i.open("GET",t,!0),i.onload=()=>{200==i.status?e(i.responseText):n(i.status,i.responseText)},i.onerror=()=>{n(i.status,i.responseText)},i.send()}downloadBinary(t,e,n){let i=new XMLHttpRequest;this.rawDataUris[t]&&(t=this.rawDataUris[t]),i.open("GET",t,!0),i.responseType="arraybuffer",i.onload=()=>{200==i.status?e(new Uint8Array(i.response)):n(i.status,i.responseText)},i.onerror=()=>{n(i.status,i.responseText)},i.send()}setRawDataURI(t,e){this.rawDataUris[this.pathPrefix+t]=e}loadBinary(t,e=null,n=null){t=this.pathPrefix+t,this.toLoad++,this.downloadBinary(t,(n=>{this.assets[t]=n,e&&e(t,n),this.toLoad--,this.loaded++}),((e,i)=>{this.errors[t]=`Couldn't load binary ${t}: status ${status}, ${i}`,n&&n(t,`Couldn't load binary ${t}: status ${status}, ${i}`),this.toLoad--,this.loaded++}))}loadText(t,e=null,n=null){t=this.pathPrefix+t,this.toLoad++,this.downloadText(t,(n=>{this.assets[t]=n,e&&e(t,n),this.toLoad--,this.loaded++}),((e,i)=>{this.errors[t]=`Couldn't load text ${t}: status ${status}, ${i}`,n&&n(t,`Couldn't load text ${t}: status ${status}, ${i}`),this.toLoad--,this.loaded++}))}loadTexture(t,e=null,n=null){let i=t=this.pathPrefix+t;this.toLoad++;let a=new Image;a.crossOrigin="anonymous",a.onload=n=>{let s=this.textureLoader(a);this.assets[i]=s,this.toLoad--,this.loaded++,e&&e(t,a)},a.onerror=e=>{this.errors[t]=`Couldn't load image ${t}`,this.toLoad--,this.loaded++,n&&n(t,`Couldn't load image ${t}`)},this.rawDataUris[t]&&(t=this.rawDataUris[t]),a.src=t}loadTextureAtlas(e,n=null,i=null){let a=e.lastIndexOf("/")>=0?e.substring(0,e.lastIndexOf("/")):"";e=this.pathPrefix+e,this.toLoad++,this.downloadText(e,(s=>{let r={count:0},l=new Array;try{new t.TextureAtlas(s,(e=>{l.push(""==a?e:a+"/"+e);let n=document.createElement("img");return n.width=16,n.height=16,new t.FakeTexture(n)}))}catch(t){let n=t;return this.errors[e]=`Couldn't load texture atlas ${e}: ${n.message}`,i&&i(e,`Couldn't load texture atlas ${e}: ${n.message}`),this.toLoad--,void this.loaded++}for(let o of l){let h=!1;this.loadTexture(o,((o,d)=>{if(r.count++,r.count==l.length)if(h)this.errors[e]=`Couldn't load texture atlas page ${o}} of atlas ${e}`,i&&i(e,`Couldn't load texture atlas page ${o} of atlas ${e}`),this.toLoad--,this.loaded++;else try{let i=new t.TextureAtlas(s,(t=>this.get(""==a?t:a+"/"+t)));this.assets[e]=i,n&&n(e,i),this.toLoad--,this.loaded++}catch(t){let n=t;this.errors[e]=`Couldn't load texture atlas ${e}: ${n.message}`,i&&i(e,`Couldn't load texture atlas ${e}: ${n.message}`),this.toLoad--,this.loaded++}}),((t,n)=>{h=!0,r.count++,r.count==l.length&&(this.errors[e]=`Couldn't load texture atlas page ${t}} of atlas ${e}`,i&&i(e,`Couldn't load texture atlas page ${t} of atlas ${e}`),this.toLoad--,this.loaded++)}))}}),((t,n)=>{this.errors[e]=`Couldn't load texture atlas ${e}: status ${status}, ${n}`,i&&i(e,`Couldn't load texture atlas ${e}: status ${status}, ${n}`),this.toLoad--,this.loaded++}))}get(t){return t=this.pathPrefix+t,this.assets[t]}remove(t){t=this.pathPrefix+t;let e=this.assets[t];e.dispose&&e.dispose(),this.assets[t]=null}removeAll(){for(let t in this.assets){let e=this.assets[t];e.dispose&&e.dispose()}this.assets={}}isLoadingComplete(){return 0==this.toLoad}getToLoad(){return this.toLoad}getLoaded(){return this.loaded}dispose(){this.removeAll()}hasErrors(){return Object.keys(this.errors).length>0}getErrors(){return this.errors}}}(spine||(spine={})),function(t){t.AtlasAttachmentLoader=class{constructor(t){this.atlas=t}newRegionAttachment(e,n,i){let a=this.atlas.findRegion(i);if(null==a)throw new Error("Region not found in atlas: "+i+" (region attachment: "+n+")");a.renderObject=a;let s=new t.RegionAttachment(n);return s.setRegion(a),s}newMeshAttachment(e,n,i){let a=this.atlas.findRegion(i);if(null==a)throw new Error("Region not found in atlas: "+i+" (mesh attachment: "+n+")");a.renderObject=a;let s=new t.MeshAttachment(n);return s.region=a,s}newBoundingBoxAttachment(e,n){return new t.BoundingBoxAttachment(n)}newPathAttachment(e,n){return new t.PathAttachment(n)}newPointAttachment(e,n){return new t.PointAttachment(n)}newClippingAttachment(e,n){return new t.ClippingAttachment(n)}}}(spine||(spine={})),function(t){let e;!function(t){t[t.Normal=0]="Normal",t[t.Additive=1]="Additive",t[t.Multiply=2]="Multiply",t[t.Screen=3]="Screen"}(e=t.BlendMode||(t.BlendMode={}))}(spine||(spine={})),function(t){t.Bone=class{constructor(t,e,n){if(this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.appliedValid=!1,this.a=0,this.b=0,this.c=0,this.d=0,this.worldY=0,this.worldX=0,this.sorted=!1,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=n,this.setToSetupPose()}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(e,n,i,a,s,r,l){this.ax=e,this.ay=n,this.arotation=i,this.ascaleX=a,this.ascaleY=s,this.ashearX=r,this.ashearY=l,this.appliedValid=!0;let o=this.parent;if(null==o){let o=this.skeleton,h=i+90+l,d=o.scaleX,u=o.scaleY;return this.a=t.MathUtils.cosDeg(i+r)*a*d,this.b=t.MathUtils.cosDeg(h)*s*d,this.c=t.MathUtils.sinDeg(i+r)*a*u,this.d=t.MathUtils.sinDeg(h)*s*u,this.worldX=e*d+o.x,void(this.worldY=n*u+o.y)}let h=o.a,d=o.b,u=o.c,c=o.d;switch(this.worldX=h*e+d*n+o.worldX,this.worldY=u*e+c*n+o.worldY,this.data.transformMode){case t.TransformMode.Normal:{let e=i+90+l,n=t.MathUtils.cosDeg(i+r)*a,o=t.MathUtils.cosDeg(e)*s,m=t.MathUtils.sinDeg(i+r)*a,f=t.MathUtils.sinDeg(e)*s;return this.a=h*n+d*m,this.b=h*o+d*f,this.c=u*n+c*m,void(this.d=u*o+c*f)}case t.TransformMode.OnlyTranslation:{let e=i+90+l;this.a=t.MathUtils.cosDeg(i+r)*a,this.b=t.MathUtils.cosDeg(e)*s,this.c=t.MathUtils.sinDeg(i+r)*a,this.d=t.MathUtils.sinDeg(e)*s;break}case t.TransformMode.NoRotationOrReflection:{let e=h*h+u*u,n=0;e>1e-4?(e=Math.abs(h*c-d*u)/e,h/=this.skeleton.scaleX,u/=this.skeleton.scaleY,d=u*e,c=h*e,n=Math.atan2(u,h)*t.MathUtils.radDeg):(h=0,u=0,n=90-Math.atan2(c,d)*t.MathUtils.radDeg);let o=i+r-n,m=i+l-n+90,f=t.MathUtils.cosDeg(o)*a,g=t.MathUtils.cosDeg(m)*s,p=t.MathUtils.sinDeg(o)*a,T=t.MathUtils.sinDeg(m)*s;this.a=h*f-d*p,this.b=h*g-d*T,this.c=u*f+c*p,this.d=u*g+c*T;break}case t.TransformMode.NoScale:case t.TransformMode.NoScaleOrReflection:{let e=t.MathUtils.cosDeg(i),n=t.MathUtils.sinDeg(i),o=(h*e+d*n)/this.skeleton.scaleX,m=(u*e+c*n)/this.skeleton.scaleY,f=Math.sqrt(o*o+m*m);f>1e-5&&(f=1/f),o*=f,m*=f,f=Math.sqrt(o*o+m*m),this.data.transformMode==t.TransformMode.NoScale&&h*c-d*u<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(f=-f);let g=Math.PI/2+Math.atan2(m,o),p=Math.cos(g)*f,T=Math.sin(g)*f,w=t.MathUtils.cosDeg(r)*a,C=t.MathUtils.cosDeg(90+l)*s,M=t.MathUtils.sinDeg(r)*a,x=t.MathUtils.sinDeg(90+l)*s;this.a=o*w+p*M,this.b=o*C+p*x,this.c=m*w+T*M,this.d=m*C+T*x;break}}this.a*=this.skeleton.scaleX,this.b*=this.skeleton.scaleX,this.c*=this.skeleton.scaleY,this.d*=this.skeleton.scaleY}setToSetupPose(){let t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.c,this.a)*t.MathUtils.radDeg}getWorldRotationY(){return Math.atan2(this.d,this.b)*t.MathUtils.radDeg}getWorldScaleX(){return Math.sqrt(this.a*this.a+this.c*this.c)}getWorldScaleY(){return Math.sqrt(this.b*this.b+this.d*this.d)}updateAppliedTransform(){this.appliedValid=!0;let e=this.parent;if(null==e)return this.ax=this.worldX,this.ay=this.worldY,this.arotation=Math.atan2(this.c,this.a)*t.MathUtils.radDeg,this.ascaleX=Math.sqrt(this.a*this.a+this.c*this.c),this.ascaleY=Math.sqrt(this.b*this.b+this.d*this.d),this.ashearX=0,void(this.ashearY=Math.atan2(this.a*this.b+this.c*this.d,this.a*this.d-this.b*this.c)*t.MathUtils.radDeg);let n=e.a,i=e.b,a=e.c,s=e.d,r=1/(n*s-i*a),l=this.worldX-e.worldX,o=this.worldY-e.worldY;this.ax=l*s*r-o*i*r,this.ay=o*n*r-l*a*r;let h=r*s,d=r*n,u=r*i,c=r*a,m=h*this.a-u*this.c,f=h*this.b-u*this.d,g=d*this.c-c*this.a,p=d*this.d-c*this.b;if(this.ashearX=0,this.ascaleX=Math.sqrt(m*m+g*g),this.ascaleX>1e-4){let e=m*p-f*g;this.ascaleY=e/this.ascaleX,this.ashearY=Math.atan2(m*f+g*p,e)*t.MathUtils.radDeg,this.arotation=Math.atan2(g,m)*t.MathUtils.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(f*f+p*p),this.ashearY=0,this.arotation=90-Math.atan2(p,f)*t.MathUtils.radDeg}worldToLocal(t){let e=this.a,n=this.b,i=this.c,a=this.d,s=1/(e*a-n*i),r=t.x-this.worldX,l=t.y-this.worldY;return t.x=r*a*s-l*n*s,t.y=l*e*s-r*i*s,t}localToWorld(t){let e=t.x,n=t.y;return t.x=e*this.a+n*this.b+this.worldX,t.y=e*this.c+n*this.d+this.worldY,t}worldToLocalRotation(e){let n=t.MathUtils.sinDeg(e),i=t.MathUtils.cosDeg(e);return Math.atan2(this.a*n-this.c*i,this.d*i-this.b*n)*t.MathUtils.radDeg+this.rotation-this.shearX}localToWorldRotation(e){e-=this.rotation-this.shearX;let n=t.MathUtils.sinDeg(e),i=t.MathUtils.cosDeg(e);return Math.atan2(i*this.c+n*this.d,i*this.a+n*this.b)*t.MathUtils.radDeg}rotateWorld(e){let n=this.a,i=this.b,a=this.c,s=this.d,r=t.MathUtils.cosDeg(e),l=t.MathUtils.sinDeg(e);this.a=r*n-l*a,this.b=r*i-l*s,this.c=l*n+r*a,this.d=l*i+r*s,this.appliedValid=!1}}}(spine||(spine={})),function(t){let e;t.BoneData=class{constructor(n,i,a){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=e.Normal,this.skinRequired=!1,this.color=new t.Color,n<0)throw new Error("index must be >= 0.");if(null==i)throw new Error("name cannot be null.");this.index=n,this.name=i,this.parent=a}},function(t){t[t.Normal=0]="Normal",t[t.OnlyTranslation=1]="OnlyTranslation",t[t.NoRotationOrReflection=2]="NoRotationOrReflection",t[t.NoScale=3]="NoScale",t[t.NoScaleOrReflection=4]="NoScaleOrReflection"}(e=t.TransformMode||(t.TransformMode={}))}(spine||(spine={})),function(t){t.ConstraintData=class{constructor(t,e,n){this.name=t,this.order=e,this.skinRequired=n}}}(spine||(spine={})),function(t){t.Event=class{constructor(t,e){if(null==e)throw new Error("data cannot be null.");this.time=t,this.data=e}}}(spine||(spine={})),function(t){t.EventData=class{constructor(t){this.name=t}}}(spine||(spine={})),function(t){t.IkConstraint=class{constructor(t,e){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){let t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix)}}apply1(e,n,i,a,s,r,l){e.appliedValid||e.updateAppliedTransform();let o=e.parent,h=o.a,d=o.b,u=o.c,c=o.d,m=-e.ashearX-e.arotation,f=0,g=0;switch(e.data.transformMode){case t.TransformMode.OnlyTranslation:f=n-e.worldX,g=i-e.worldY;break;case t.TransformMode.NoRotationOrReflection:let a=Math.abs(h*c-d*u)/(h*h+u*u),s=h/e.skeleton.scaleX,r=u/e.skeleton.scaleY;d=-r*a*e.skeleton.scaleX,c=s*a*e.skeleton.scaleY,m+=Math.atan2(r,s)*t.MathUtils.radDeg;default:let l=n-o.worldX,p=i-o.worldY,T=h*c-d*u;f=(l*c-p*d)/T-e.ax,g=(p*h-l*u)/T-e.ay}m+=Math.atan2(g,f)*t.MathUtils.radDeg,e.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let p=e.ascaleX,T=e.ascaleY;if(a||s){switch(e.data.transformMode){case t.TransformMode.NoScale:case t.TransformMode.NoScaleOrReflection:f=n-e.worldX,g=i-e.worldY}let o=e.data.length*p,h=Math.sqrt(f*f+g*g);if(a&&h<o||s&&h>o&&o>1e-4){let t=(h/o-1)*l+1;p*=t,r&&(T*=t)}}e.updateWorldTransformWith(e.ax,e.ay,e.arotation+m*l,p,T,e.ashearX,e.ashearY)}apply2(e,n,i,a,s,r,l,o){if(0==o)return void n.updateWorldTransform();e.appliedValid||e.updateAppliedTransform(),n.appliedValid||n.updateAppliedTransform();let h=e.ax,d=e.ay,u=e.ascaleX,c=u,m=e.ascaleY,f=n.ascaleX,g=0,p=0,T=0;u<0?(u=-u,g=180,T=-1):(g=0,T=1),m<0&&(m=-m,T=-T),f<0?(f=-f,p=180):p=0;let w=n.ax,C=0,M=0,x=0,A=e.a,E=e.b,S=e.c,I=e.d,y=Math.abs(u-m)<=1e-4;y?(C=n.ay,M=A*w+E*C+e.worldX,x=S*w+I*C+e.worldY):(C=0,M=A*w+e.worldX,x=S*w+e.worldY);let R=e.parent;A=R.a,E=R.b,S=R.c,I=R.d;let b,P,k=1/(A*I-E*S),V=M-R.worldX,v=x-R.worldY,F=(V*I-v*E)*k-h,N=(v*A-V*S)*k-d,U=Math.sqrt(F*F+N*N),B=n.data.length*f;if(U<1e-4)return this.apply1(e,i,a,!1,r,!1,o),void n.updateWorldTransformWith(w,C,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);V=i-R.worldX,v=a-R.worldY;let Y=(V*I-v*E)*k-h,X=(v*A-V*S)*k-d,L=Y*Y+X*X;if(0!=l){l*=u*(f+1)/2;let t=Math.sqrt(L),e=t-U-B*u+l;if(e>0){let n=Math.min(1,e/(2*l))-1;n=(e-l*(1-n*n))/t,Y-=n*Y,X-=n*X,L=Y*Y+X*X}}t:if(y){B*=u;let t=(L-U*U-B*B)/(2*U*B);t<-1?t=-1:t>1&&(t=1,r&&(c*=(Math.sqrt(L)/(U+B)-1)*o+1)),P=Math.acos(t)*s,A=U+B*t,E=B*Math.sin(P),b=Math.atan2(X*A-Y*E,Y*A+X*E)}else{A=u*B,E=m*B;let e=A*A,n=E*E,i=Math.atan2(X,Y);S=n*U*U+e*L-e*n;let a=-2*n*U,r=n-e;if(I=a*a-4*r*S,I>=0){let t=Math.sqrt(I);a<0&&(t=-t),t=-(a+t)/2;let e=t/r,n=S/t,l=Math.abs(e)<Math.abs(n)?e:n;if(l*l<=L){v=Math.sqrt(L-l*l)*s,b=i-Math.atan2(v,l),P=Math.atan2(v/m,(l-U)/u);break t}}let l=t.MathUtils.PI,o=U-A,h=o*o,d=0,c=0,f=U+A,g=f*f,p=0;S=-A*U/(e-n),S>=-1&&S<=1&&(S=Math.acos(S),V=A*Math.cos(S)+U,v=E*Math.sin(S),I=V*V+v*v,I<h&&(l=S,h=I,o=V,d=v),I>g&&(c=S,g=I,f=V,p=v)),L<=(h+g)/2?(b=i-Math.atan2(d*s,o),P=l*s):(b=i-Math.atan2(p*s,f),P=c*s)}let D=Math.atan2(C,w)*T,O=e.arotation;b=(b-D)*t.MathUtils.radDeg+g-O,b>180?b-=360:b<-180&&(b+=360),e.updateWorldTransformWith(h,d,O+b*o,c,e.ascaleY,0,0),O=n.arotation,P=((P+D)*t.MathUtils.radDeg-n.ashearX)*T+p-O,P>180?P-=360:P<-180&&(P+=360),n.updateWorldTransformWith(w,C,O+P*o,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}}(spine||(spine={})),function(t){class IkConstraintData extends t.ConstraintData{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}t.IkConstraintData=IkConstraintData}(spine||(spine={})),function(t){class PathConstraint{constructor(t,e){if(this.position=0,this.spacing=0,this.rotateMix=0,this.translateMix=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,null==t)throw new Error("data cannot be null.");if(null==e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,i=t.bones.length;n<i;n++)this.bones.push(e.findBone(t.bones[n].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}isActive(){return this.active}apply(){this.update()}update(){let e=this.target.getAttachment();if(!(e instanceof t.PathAttachment))return;let n=this.rotateMix,i=this.translateMix,a=n>0;if(!(i>0)&&!a)return;let s=this.data,r=s.spacingMode==t.SpacingMode.Percent,l=s.rotateMode,o=l==t.RotateMode.Tangent,h=l==t.RotateMode.ChainScale,d=this.bones.length,u=o?d:d+1,c=this.bones,m=t.Utils.setArraySize(this.spaces,u),f=null,g=this.spacing;if(h||!r){h&&(f=t.Utils.setArraySize(this.lengths,d));let e=s.spacingMode==t.SpacingMode.Length;for(let t=0,n=u-1;t<n;){let n=c[t],i=n.data.length;if(i<PathConstraint.epsilon)h&&(f[t]=0),m[++t]=0;else if(r){if(h){let e=i*n.a,a=i*n.c,s=Math.sqrt(e*e+a*a);f[t]=s}m[++t]=g}else{let a=i*n.a,s=i*n.c,r=Math.sqrt(a*a+s*s);h&&(f[t]=r),m[++t]=(e?i+g:g)*r/i}}}else for(let t=1;t<u;t++)m[t]=g;let p=this.computeWorldPositions(e,u,o,s.positionMode==t.PositionMode.Percent,r),T=p[0],w=p[1],C=s.offsetRotation,M=!1;if(0==C)M=l==t.RotateMode.Chain;else{M=!1;let e=this.target.bone;C*=e.a*e.d-e.b*e.c>0?t.MathUtils.degRad:-t.MathUtils.degRad}for(let e=0,s=3;e<d;e++,s+=3){let r=c[e];r.worldX+=(T-r.worldX)*i,r.worldY+=(w-r.worldY)*i;let l=p[s],d=p[s+1],u=l-T,g=d-w;if(h){let t=f[e];if(0!=t){let e=(Math.sqrt(u*u+g*g)/t-1)*n+1;r.a*=e,r.c*=e}}if(T=l,w=d,a){let i=r.a,a=r.b,l=r.c,h=r.d,d=0,c=0,f=0;if(d=o?p[s-1]:0==m[e+1]?p[s+2]:Math.atan2(g,u),d-=Math.atan2(l,i),M){c=Math.cos(d),f=Math.sin(d);let t=r.data.length;T+=(t*(c*i-f*l)-u)*n,w+=(t*(f*i+c*l)-g)*n}else d+=C;d>t.MathUtils.PI?d-=t.MathUtils.PI2:d<-t.MathUtils.PI&&(d+=t.MathUtils.PI2),d*=n,c=Math.cos(d),f=Math.sin(d),r.a=c*i-f*l,r.b=c*a-f*h,r.c=f*i+c*l,r.d=f*a+c*h}r.appliedValid=!1}}computeWorldPositions(e,n,i,a,s){let r=this.target,l=this.position,o=this.spaces,h=t.Utils.setArraySize(this.positions,3*n+2),d=null,u=e.closed,c=e.worldVerticesLength,m=c/6,f=PathConstraint.NONE;if(!e.constantSpeed){let g=e.lengths;m-=u?1:2;let p=g[m];if(a&&(l*=p),s)for(let t=1;t<n;t++)o[t]*=p;d=t.Utils.setArraySize(this.world,8);for(let t=0,a=0,s=0;t<n;t++,a+=3){let n=o[t];l+=n;let T=l;if(u)T%=p,T<0&&(T+=p),s=0;else{if(T<0){f!=PathConstraint.BEFORE&&(f=PathConstraint.BEFORE,e.computeWorldVertices(r,2,4,d,0,2)),this.addBeforePosition(T,d,0,h,a);continue}if(T>p){f!=PathConstraint.AFTER&&(f=PathConstraint.AFTER,e.computeWorldVertices(r,c-6,4,d,0,2)),this.addAfterPosition(T-p,d,0,h,a);continue}}for(;;s++){let t=g[s];if(!(T>t)){if(0==s)T/=t;else{let e=g[s-1];T=(T-e)/(t-e)}break}}s!=f&&(f=s,u&&s==m?(e.computeWorldVertices(r,c-4,4,d,0,2),e.computeWorldVertices(r,0,4,d,4,2)):e.computeWorldVertices(r,6*s+2,8,d,0,2)),this.addCurvePosition(T,d[0],d[1],d[2],d[3],d[4],d[5],d[6],d[7],h,a,i||t>0&&0==n)}return h}u?(c+=2,d=t.Utils.setArraySize(this.world,c),e.computeWorldVertices(r,2,c-4,d,0,2),e.computeWorldVertices(r,0,2,d,c-4,2),d[c-2]=d[0],d[c-1]=d[1]):(m--,c-=4,d=t.Utils.setArraySize(this.world,c),e.computeWorldVertices(r,2,c,d,0,2));let g=t.Utils.setArraySize(this.curves,m),p=0,T=d[0],w=d[1],C=0,M=0,x=0,A=0,E=0,S=0,I=0,y=0,R=0,b=0,P=0,k=0,V=0,v=0;for(let t=0,e=2;t<m;t++,e+=6)C=d[e],M=d[e+1],x=d[e+2],A=d[e+3],E=d[e+4],S=d[e+5],I=.1875*(T-2*C+x),y=.1875*(w-2*M+A),R=.09375*(3*(C-x)-T+E),b=.09375*(3*(M-A)-w+S),P=2*I+R,k=2*y+b,V=.75*(C-T)+I+.16666667*R,v=.75*(M-w)+y+.16666667*b,p+=Math.sqrt(V*V+v*v),V+=P,v+=k,P+=R,k+=b,p+=Math.sqrt(V*V+v*v),V+=P,v+=k,p+=Math.sqrt(V*V+v*v),V+=P+R,v+=k+b,p+=Math.sqrt(V*V+v*v),g[t]=p,T=E,w=S;if(l*=a?p:p/e.lengths[m-1],s)for(let t=1;t<n;t++)o[t]*=p;let F=this.segments,N=0;for(let t=0,e=0,a=0,s=0;t<n;t++,e+=3){let n=o[t];l+=n;let r=l;if(u)r%=p,r<0&&(r+=p),a=0;else{if(r<0){this.addBeforePosition(r,d,0,h,e);continue}if(r>p){this.addAfterPosition(r-p,d,c-4,h,e);continue}}for(;;a++){let t=g[a];if(!(r>t)){if(0==a)r/=t;else{let e=g[a-1];r=(r-e)/(t-e)}break}}if(a!=f){f=a;let t=6*a;for(T=d[t],w=d[t+1],C=d[t+2],M=d[t+3],x=d[t+4],A=d[t+5],E=d[t+6],S=d[t+7],I=.03*(T-2*C+x),y=.03*(w-2*M+A),R=.006*(3*(C-x)-T+E),b=.006*(3*(M-A)-w+S),P=2*I+R,k=2*y+b,V=.3*(C-T)+I+.16666667*R,v=.3*(M-w)+y+.16666667*b,N=Math.sqrt(V*V+v*v),F[0]=N,t=1;t<8;t++)V+=P,v+=k,P+=R,k+=b,N+=Math.sqrt(V*V+v*v),F[t]=N;V+=P,v+=k,N+=Math.sqrt(V*V+v*v),F[8]=N,V+=P+R,v+=k+b,N+=Math.sqrt(V*V+v*v),F[9]=N,s=0}for(r*=N;;s++){let t=F[s];if(!(r>t)){if(0==s)r/=t;else{let e=F[s-1];r=s+(r-e)/(t-e)}break}}this.addCurvePosition(.1*r,T,w,C,M,x,A,E,S,h,e,i||t>0&&0==n)}return h}addBeforePosition(t,e,n,i,a){let s=e[n],r=e[n+1],l=e[n+2]-s,o=e[n+3]-r,h=Math.atan2(o,l);i[a]=s+t*Math.cos(h),i[a+1]=r+t*Math.sin(h),i[a+2]=h}addAfterPosition(t,e,n,i,a){let s=e[n+2],r=e[n+3],l=s-e[n],o=r-e[n+1],h=Math.atan2(o,l);i[a]=s+t*Math.cos(h),i[a+1]=r+t*Math.sin(h),i[a+2]=h}addCurvePosition(t,e,n,i,a,s,r,l,o,h,d,u){if(0==t||isNaN(t))return h[d]=e,h[d+1]=n,void(h[d+2]=Math.atan2(a-n,i-e));let c=t*t,m=c*t,f=1-t,g=f*f,p=g*f,T=f*t,w=3*T,C=f*w,M=w*t,x=e*p+i*C+s*M+l*m,A=n*p+a*C+r*M+o*m;h[d]=x,h[d+1]=A,u&&(h[d+2]=t<.001?Math.atan2(a-n,i-e):Math.atan2(A-(n*g+a*T*2+r*c),x-(e*g+i*T*2+s*c)))}}PathConstraint.NONE=-1,PathConstraint.BEFORE=-2,PathConstraint.AFTER=-3,PathConstraint.epsilon=1e-5,t.PathConstraint=PathConstraint}(spine||(spine={})),function(t){class PathConstraintData extends t.ConstraintData{constructor(t){super(t,0,!1),this.bones=new Array}}let e,n,i;t.PathConstraintData=PathConstraintData,function(t){t[t.Fixed=0]="Fixed",t[t.Percent=1]="Percent"}(e=t.PositionMode||(t.PositionMode={})),function(t){t[t.Length=0]="Length",t[t.Fixed=1]="Fixed",t[t.Percent=2]="Percent"}(n=t.SpacingMode||(t.SpacingMode={})),function(t){t[t.Tangent=0]="Tangent",t[t.Chain=1]="Chain",t[t.ChainScale=2]="ChainScale"}(i=t.RotateMode||(t.RotateMode={}))}(spine||(spine={})),function(t){class Assets{constructor(t){this.toLoad=new Array,this.assets={},this.clientId=t}loaded(){let t=0;for(let e in this.assets)t++;return t}}t.SharedAssetManager=class{constructor(t=""){this.clientAssets={},this.queuedAssets={},this.rawAssets={},this.errors={},this.pathPrefix=t}queueAsset(t,e,n){let i=this.clientAssets[t];return null==i&&(i=new Assets(t),this.clientAssets[t]=i),null!==e&&(i.textureLoader=e),i.toLoad.push(n),this.queuedAssets[n]!==n&&(this.queuedAssets[n]=n,!0)}loadText(t,e){if(e=this.pathPrefix+e,!this.queueAsset(t,null,e))return;let n=new XMLHttpRequest;n.overrideMimeType("text/html"),n.onreadystatechange=()=>{n.readyState==XMLHttpRequest.DONE&&(n.status>=200&&n.status<300?this.rawAssets[e]=n.responseText:this.errors[e]=`Couldn't load text ${e}: status ${n.status}, ${n.responseText}`)},n.open("GET",e,!0),n.send()}loadJson(t,e){if(e=this.pathPrefix+e,!this.queueAsset(t,null,e))return;let n=new XMLHttpRequest;n.overrideMimeType("text/html"),n.onreadystatechange=()=>{n.readyState==XMLHttpRequest.DONE&&(n.status>=200&&n.status<300?this.rawAssets[e]=JSON.parse(n.responseText):this.errors[e]=`Couldn't load text ${e}: status ${n.status}, ${n.responseText}`)},n.open("GET",e,!0),n.send()}loadTexture(t,e,n){if(n=this.pathPrefix+n,!this.queueAsset(t,e,n))return;if(!!("undefined"==typeof window||"undefined"==typeof navigator||!window.document)&&"undefined"!=typeof importScripts){fetch(n,{mode:"cors"}).then((t=>(t.ok||(this.errors[n]="Couldn't load image "+n),t.blob()))).then((t=>createImageBitmap(t,{premultiplyAlpha:"none",colorSpaceConversion:"none"}))).then((t=>{this.rawAssets[n]=t}))}else{let t=new Image;t.crossOrigin="anonymous",t.onload=e=>{this.rawAssets[n]=t},t.onerror=t=>{this.errors[n]=`Couldn't load image ${n}`},t.src=n}}get(t,e){e=this.pathPrefix+e;let n=this.clientAssets[t];return null==n||n.assets[e]}updateClientAssets(t){let e=!!("undefined"==typeof window||"undefined"==typeof navigator||!window.document)&&"undefined"!=typeof importScripts;for(let n=0;n<t.toLoad.length;n++){let i=t.toLoad[n],a=t.assets[i];if(null==a){let n=this.rawAssets[i];if(null==n)continue;e?n instanceof ImageBitmap?t.assets[i]=t.textureLoader(n):t.assets[i]=n:n instanceof HTMLImageElement?t.assets[i]=t.textureLoader(n):t.assets[i]=n}}}isLoadingComplete(t){let e=this.clientAssets[t];return null==e||(this.updateClientAssets(e),e.toLoad.length==e.loaded())}dispose(){}hasErrors(){return Object.keys(this.errors).length>0}getErrors(){return this.errors}}}(spine||(spine={})),function(t){t.Skeleton=class{constructor(e){if(this._updateCache=new Array,this.updateCacheReset=new Array,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,null==e)throw new Error("data cannot be null.");this.data=e,this.bones=new Array;for(let n=0;n<e.bones.length;n++){let i,a=e.bones[n];if(null==a.parent)i=new t.Bone(a,this,null);else{let e=this.bones[a.parent.index];i=new t.Bone(a,this,e),e.children.push(i)}this.bones.push(i)}this.slots=new Array,this.drawOrder=new Array;for(let n=0;n<e.slots.length;n++){let i=e.slots[n],a=this.bones[i.boneData.index],s=new t.Slot(i,a);this.slots.push(s),this.drawOrder.push(s)}this.ikConstraints=new Array;for(let n=0;n<e.ikConstraints.length;n++){let i=e.ikConstraints[n];this.ikConstraints.push(new t.IkConstraint(i,this))}this.transformConstraints=new Array;for(let n=0;n<e.transformConstraints.length;n++){let i=e.transformConstraints[n];this.transformConstraints.push(new t.TransformConstraint(i,this))}this.pathConstraints=new Array;for(let n=0;n<e.pathConstraints.length;n++){let i=e.pathConstraints[n];this.pathConstraints.push(new t.PathConstraint(i,this))}this.color=new t.Color(1,1,1,1),this.updateCache()}updateCache(){this._updateCache.length=0,this.updateCacheReset.length=0;let t=this.bones;for(let e=0,n=t.length;e<n;e++){let n=t[e];n.sorted=n.data.skinRequired,n.active=!n.sorted}if(null!=this.skin){let t=this.skin.bones;for(let e=0,n=this.skin.bones.length;e<n;e++){let n=this.bones[t[e].index];do{n.sorted=!1,n.active=!0,n=n.parent}while(null!=n)}}let e=this.ikConstraints,n=this.transformConstraints,i=this.pathConstraints,a=e.length,s=n.length,r=i.length,l=a+s+r;t:for(let t=0;t<l;t++){for(let n=0;n<a;n++){let i=e[n];if(i.data.order==t){this.sortIkConstraint(i);continue t}}for(let e=0;e<s;e++){let i=n[e];if(i.data.order==t){this.sortTransformConstraint(i);continue t}}for(let e=0;e<r;e++){let n=i[e];if(n.data.order==t){this.sortPathConstraint(n);continue t}}}for(let e=0,n=t.length;e<n;e++)this.sortBone(t[e])}sortIkConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||null!=this.skin&&t.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;let n=e.target;this.sortBone(n);let i=e.bones,a=i[0];if(this.sortBone(a),i.length>1){let t=i[i.length-1];this._updateCache.indexOf(t)>-1||this.updateCacheReset.push(t)}this._updateCache.push(e),this.sortReset(a.children),i[i.length-1].sorted=!0}sortPathConstraint(e){if(e.active=e.target.bone.isActive()&&(!e.data.skinRequired||null!=this.skin&&t.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;let n=e.target,i=n.data.index,a=n.bone;null!=this.skin&&this.sortPathConstraintAttachment(this.skin,i,a),null!=this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,i,a);for(let t=0,e=this.data.skins.length;t<e;t++)this.sortPathConstraintAttachment(this.data.skins[t],i,a);let s=n.getAttachment();s instanceof t.PathAttachment&&this.sortPathConstraintAttachmentWith(s,a);let r=e.bones,l=r.length;for(let t=0;t<l;t++)this.sortBone(r[t]);this._updateCache.push(e);for(let t=0;t<l;t++)this.sortReset(r[t].children);for(let t=0;t<l;t++)r[t].sorted=!0}sortTransformConstraint(e){if(e.active=e.target.isActive()&&(!e.data.skinRequired||null!=this.skin&&t.Utils.contains(this.skin.constraints,e.data,!0)),!e.active)return;this.sortBone(e.target);let n=e.bones,i=n.length;if(e.data.local)for(let t=0;t<i;t++){let e=n[t];this.sortBone(e.parent),this._updateCache.indexOf(e)>-1||this.updateCacheReset.push(e)}else for(let t=0;t<i;t++)this.sortBone(n[t]);this._updateCache.push(e);for(let t=0;t<i;t++)this.sortReset(n[t].children);for(let t=0;t<i;t++)n[t].sorted=!0}sortPathConstraintAttachment(t,e,n){let i=t.attachments[e];if(i)for(let t in i)this.sortPathConstraintAttachmentWith(i[t],n)}sortPathConstraintAttachmentWith(e,n){if(!(e instanceof t.PathAttachment))return;let i=e.bones;if(null==i)this.sortBone(n);else{let t=this.bones,e=0;for(;e<i.length;){let n=i[e++];for(let a=e+n;e<a;e++){let n=i[e];this.sortBone(t[n])}}}}sortBone(t){if(t.sorted)return;let e=t.parent;null!=e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,n=t.length;e<n;e++){let n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){let t=this.updateCacheReset;for(let e=0,n=t.length;e<n;e++){let n=t[e];n.ax=n.x,n.ay=n.y,n.arotation=n.rotation,n.ascaleX=n.scaleX,n.ascaleY=n.scaleY,n.ashearX=n.shearX,n.ashearY=n.shearY,n.appliedValid=!0}let e=this._updateCache;for(let t=0,n=e.length;t<n;t++)e[t].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){let t=this.bones;for(let e=0,n=t.length;e<n;e++)t[e].setToSetupPose();let e=this.ikConstraints;for(let t=0,n=e.length;t<n;t++){let n=e[t];n.mix=n.data.mix,n.softness=n.data.softness,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch}let n=this.transformConstraints;for(let t=0,e=n.length;t<e;t++){let e=n[t],i=e.data;e.rotateMix=i.rotateMix,e.translateMix=i.translateMix,e.scaleMix=i.scaleMix,e.shearMix=i.shearMix}let i=this.pathConstraints;for(let t=0,e=i.length;t<e;t++){let e=i[t],n=e.data;e.position=n.position,e.spacing=n.spacing,e.rotateMix=n.rotateMix,e.translateMix=n.translateMix}}setSlotsToSetupPose(){let e=this.slots;t.Utils.arrayCopy(e,0,this.drawOrder,0,e.length);for(let t=0,n=e.length;t<n;t++)e[t].setToSetupPose()}getRootBone(){return 0==this.bones.length?null:this.bones[0]}findBone(t){if(null==t)throw new Error("boneName cannot be null.");let e=this.bones;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.data.name==t)return i}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");let e=this.bones;for(let n=0,i=e.length;n<i;n++)if(e[n].data.name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");let e=this.slots;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.data.name==t)return i}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");let e=this.slots;for(let n=0,i=e.length;n<i;n++)if(e[n].data.name==t)return n;return-1}setSkinByName(t){let e=this.data.findSkin(t);if(null==e)throw new Error("Skin not found: "+t);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(null!=t)if(null!=this.skin)t.attachAll(this,this.skin);else{let e=this.slots;for(let n=0,i=e.length;n<i;n++){let i=e[n],a=i.data.attachmentName;if(null!=a){let e=t.getAttachment(n,a);null!=e&&i.setAttachment(e)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)}getAttachment(t,e){if(null==e)throw new Error("attachmentName cannot be null.");if(null!=this.skin){let n=this.skin.getAttachment(t,e);if(null!=n)return n}return null!=this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(null==t)throw new Error("slotName cannot be null.");let n=this.slots;for(let i=0,a=n.length;i<a;i++){let a=n[i];if(a.data.name==t){let n=null;if(null!=e&&(n=this.getAttachment(i,e),null==n))throw new Error("Attachment not found: "+e+", for slot: "+t);return void a.setAttachment(n)}}throw new Error("Slot not found: "+t)}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");let e=this.ikConstraints;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.data.name==t)return i}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");let e=this.transformConstraints;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.data.name==t)return i}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");let e=this.pathConstraints;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.data.name==t)return i}return null}getBounds(e,n,i=new Array(2)){if(null==e)throw new Error("offset cannot be null.");if(null==n)throw new Error("size cannot be null.");let a=this.drawOrder,s=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;for(let e=0,n=a.length;e<n;e++){let n=a[e];if(!n.bone.active)continue;let h=0,d=null,u=n.getAttachment();if(u instanceof t.RegionAttachment)h=8,d=t.Utils.setArraySize(i,h,0),u.computeWorldVertices(n.bone,d,0,2);else if(u instanceof t.MeshAttachment){let e=u;h=e.worldVerticesLength,d=t.Utils.setArraySize(i,h,0),e.computeWorldVertices(n,0,h,d,0,2)}if(null!=d)for(let t=0,e=d.length;t<e;t+=2){let e=d[t],n=d[t+1];s=Math.min(s,e),r=Math.min(r,n),l=Math.max(l,e),o=Math.max(o,n)}}e.set(s,r),n.set(l-s,o-r)}update(t){this.time+=t}}}(spine||(spine={})),function(t){class SkeletonBinary{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(e){let n=this.scale,i=new t.SkeletonData;i.name="";let a=new BinaryInput(e);if(i.hash=a.readString(),i.version=a.readString(),"3.8.75"==i.version)throw new Error("Unsupported skeleton data, please export with a newer version of Spine.");i.x=a.readFloat(),i.y=a.readFloat(),i.width=a.readFloat(),i.height=a.readFloat();let s=a.readBoolean();s&&(i.fps=a.readFloat(),i.imagesPath=a.readString(),i.audioPath=a.readString());let r=0;r=a.readInt(!0);for(let t=0;t<r;t++)a.strings.push(a.readString());r=a.readInt(!0);for(let e=0;e<r;e++){let r=a.readString(),l=0==e?null:i.bones[a.readInt(!0)],o=new t.BoneData(e,r,l);o.rotation=a.readFloat(),o.x=a.readFloat()*n,o.y=a.readFloat()*n,o.scaleX=a.readFloat(),o.scaleY=a.readFloat(),o.shearX=a.readFloat(),o.shearY=a.readFloat(),o.length=a.readFloat()*n,o.transformMode=SkeletonBinary.TransformModeValues[a.readInt(!0)],o.skinRequired=a.readBoolean(),s&&t.Color.rgba8888ToColor(o.color,a.readInt32()),i.bones.push(o)}r=a.readInt(!0);for(let e=0;e<r;e++){let n=a.readString(),s=i.bones[a.readInt(!0)],r=new t.SlotData(e,n,s);t.Color.rgba8888ToColor(r.color,a.readInt32());let l=a.readInt32();-1!=l&&t.Color.rgb888ToColor(r.darkColor=new t.Color,l),r.attachmentName=a.readStringRef(),r.blendMode=SkeletonBinary.BlendModeValues[a.readInt(!0)],i.slots.push(r)}r=a.readInt(!0);for(let e,s=0;s<r;s++){let s=new t.IkConstraintData(a.readString());s.order=a.readInt(!0),s.skinRequired=a.readBoolean(),e=a.readInt(!0);for(let t=0;t<e;t++)s.bones.push(i.bones[a.readInt(!0)]);s.target=i.bones[a.readInt(!0)],s.mix=a.readFloat(),s.softness=a.readFloat()*n,s.bendDirection=a.readByte(),s.compress=a.readBoolean(),s.stretch=a.readBoolean(),s.uniform=a.readBoolean(),i.ikConstraints.push(s)}r=a.readInt(!0);for(let e,s=0;s<r;s++){let s=new t.TransformConstraintData(a.readString());s.order=a.readInt(!0),s.skinRequired=a.readBoolean(),e=a.readInt(!0);for(let t=0;t<e;t++)s.bones.push(i.bones[a.readInt(!0)]);s.target=i.bones[a.readInt(!0)],s.local=a.readBoolean(),s.relative=a.readBoolean(),s.offsetRotation=a.readFloat(),s.offsetX=a.readFloat()*n,s.offsetY=a.readFloat()*n,s.offsetScaleX=a.readFloat(),s.offsetScaleY=a.readFloat(),s.offsetShearY=a.readFloat(),s.rotateMix=a.readFloat(),s.translateMix=a.readFloat(),s.scaleMix=a.readFloat(),s.shearMix=a.readFloat(),i.transformConstraints.push(s)}r=a.readInt(!0);for(let e,s=0;s<r;s++){let s=new t.PathConstraintData(a.readString());s.order=a.readInt(!0),s.skinRequired=a.readBoolean(),e=a.readInt(!0);for(let t=0;t<e;t++)s.bones.push(i.bones[a.readInt(!0)]);s.target=i.slots[a.readInt(!0)],s.positionMode=SkeletonBinary.PositionModeValues[a.readInt(!0)],s.spacingMode=SkeletonBinary.SpacingModeValues[a.readInt(!0)],s.rotateMode=SkeletonBinary.RotateModeValues[a.readInt(!0)],s.offsetRotation=a.readFloat(),s.position=a.readFloat(),s.positionMode==t.PositionMode.Fixed&&(s.position*=n),s.spacing=a.readFloat(),s.spacingMode!=t.SpacingMode.Length&&s.spacingMode!=t.SpacingMode.Fixed||(s.spacing*=n),s.rotateMix=a.readFloat(),s.translateMix=a.readFloat(),i.pathConstraints.push(s)}let l=this.readSkin(a,i,!0,s);null!=l&&(i.defaultSkin=l,i.skins.push(l));{let e=i.skins.length;for(t.Utils.setArraySize(i.skins,r=e+a.readInt(!0));e<r;e++)i.skins[e]=this.readSkin(a,i,!1,s)}r=this.linkedMeshes.length;for(let t=0;t<r;t++){let e=this.linkedMeshes[t],n=null==e.skin?i.defaultSkin:i.findSkin(e.skin);if(null==n)throw new Error("Skin not found: "+e.skin);let a=n.getAttachment(e.slotIndex,e.parent);if(null==a)throw new Error("Parent mesh not found: "+e.parent);e.mesh.deformAttachment=e.inheritDeform?a:e.mesh,e.mesh.setParentMesh(a),e.mesh.updateUVs()}this.linkedMeshes.length=0,r=a.readInt(!0);for(let e=0;e<r;e++){let e=new t.EventData(a.readStringRef());e.intValue=a.readInt(!1),e.floatValue=a.readFloat(),e.stringValue=a.readString(),e.audioPath=a.readString(),null!=e.audioPath&&(e.volume=a.readFloat(),e.balance=a.readFloat()),i.events.push(e)}r=a.readInt(!0);for(let t=0;t<r;t++)i.animations.push(this.readAnimation(a,a.readString(),i));return i}readSkin(e,n,i,a){let s=null,r=0;if(i){if(r=e.readInt(!0),0==r)return null;s=new t.Skin("default")}else{s=new t.Skin(e.readStringRef()),s.bones.length=e.readInt(!0);for(let t=0,i=s.bones.length;t<i;t++)s.bones[t]=n.bones[e.readInt(!0)];for(let t=0,i=e.readInt(!0);t<i;t++)s.constraints.push(n.ikConstraints[e.readInt(!0)]);for(let t=0,i=e.readInt(!0);t<i;t++)s.constraints.push(n.transformConstraints[e.readInt(!0)]);for(let t=0,i=e.readInt(!0);t<i;t++)s.constraints.push(n.pathConstraints[e.readInt(!0)]);r=e.readInt(!0)}for(let t=0;t<r;t++){let t=e.readInt(!0);for(let i=0,r=e.readInt(!0);i<r;i++){let i=e.readStringRef(),r=this.readAttachment(e,n,s,t,i,a);null!=r&&s.setAttachment(t,i,r)}}return s}readAttachment(e,n,i,a,s,r){let l=this.scale,o=e.readStringRef();null==o&&(o=s);let h=e.readByte();switch(SkeletonBinary.AttachmentTypeValues[h]){case t.AttachmentType.Region:{let n=e.readStringRef(),a=e.readFloat(),s=e.readFloat(),r=e.readFloat(),h=e.readFloat(),d=e.readFloat(),u=e.readFloat(),c=e.readFloat(),m=e.readInt32();null==n&&(n=o);let f=this.attachmentLoader.newRegionAttachment(i,o,n);return null==f?null:(f.path=n,f.x=s*l,f.y=r*l,f.scaleX=h,f.scaleY=d,f.rotation=a,f.width=u*l,f.height=c*l,t.Color.rgba8888ToColor(f.color,m),f.updateOffset(),f)}case t.AttachmentType.BoundingBox:{let n=e.readInt(!0),a=this.readVertices(e,n),s=r?e.readInt32():0,l=this.attachmentLoader.newBoundingBoxAttachment(i,o);return null==l?null:(l.worldVerticesLength=n<<1,l.vertices=a.vertices,l.bones=a.bones,r&&t.Color.rgba8888ToColor(l.color,s),l)}case t.AttachmentType.Mesh:{let n=e.readStringRef(),a=e.readInt32(),s=e.readInt(!0),h=this.readFloatArray(e,s<<1,1),d=this.readShortArray(e),u=this.readVertices(e,s),c=e.readInt(!0),m=null,f=0,g=0;r&&(m=this.readShortArray(e),f=e.readFloat(),g=e.readFloat()),null==n&&(n=o);let p=this.attachmentLoader.newMeshAttachment(i,o,n);return null==p?null:(p.path=n,t.Color.rgba8888ToColor(p.color,a),p.bones=u.bones,p.vertices=u.vertices,p.worldVerticesLength=s<<1,p.triangles=d,p.regionUVs=h,p.updateUVs(),p.hullLength=c<<1,r&&(p.edges=m,p.width=f*l,p.height=g*l),p)}case t.AttachmentType.LinkedMesh:{let n=e.readStringRef(),s=e.readInt32(),h=e.readStringRef(),d=e.readStringRef(),u=e.readBoolean(),c=0,m=0;r&&(c=e.readFloat(),m=e.readFloat()),null==n&&(n=o);let f=this.attachmentLoader.newMeshAttachment(i,o,n);return null==f?null:(f.path=n,t.Color.rgba8888ToColor(f.color,s),r&&(f.width=c*l,f.height=m*l),this.linkedMeshes.push(new LinkedMesh(f,h,a,d,u)),f)}case t.AttachmentType.Path:{let n=e.readBoolean(),a=e.readBoolean(),s=e.readInt(!0),h=this.readVertices(e,s),d=t.Utils.newArray(s/3,0);for(let t=0,n=d.length;t<n;t++)d[t]=e.readFloat()*l;let u=r?e.readInt32():0,c=this.attachmentLoader.newPathAttachment(i,o);return null==c?null:(c.closed=n,c.constantSpeed=a,c.worldVerticesLength=s<<1,c.vertices=h.vertices,c.bones=h.bones,c.lengths=d,r&&t.Color.rgba8888ToColor(c.color,u),c)}case t.AttachmentType.Point:{let n=e.readFloat(),a=e.readFloat(),s=e.readFloat(),h=r?e.readInt32():0,d=this.attachmentLoader.newPointAttachment(i,o);return null==d?null:(d.x=a*l,d.y=s*l,d.rotation=n,r&&t.Color.rgba8888ToColor(d.color,h),d)}case t.AttachmentType.Clipping:{let a=e.readInt(!0),s=e.readInt(!0),l=this.readVertices(e,s),h=r?e.readInt32():0,d=this.attachmentLoader.newClippingAttachment(i,o);return null==d?null:(d.endSlot=n.slots[a],d.worldVerticesLength=s<<1,d.vertices=l.vertices,d.bones=l.bones,r&&t.Color.rgba8888ToColor(d.color,h),d)}}return null}readVertices(e,n){let i=n<<1,a=new Vertices,s=this.scale;if(!e.readBoolean())return a.vertices=this.readFloatArray(e,i,s),a;let r=new Array,l=new Array;for(let t=0;t<n;t++){let t=e.readInt(!0);l.push(t);for(let n=0;n<t;n++)l.push(e.readInt(!0)),r.push(e.readFloat()*s),r.push(e.readFloat()*s),r.push(e.readFloat())}return a.vertices=t.Utils.toFloatArray(r),a.bones=l,a}readFloatArray(t,e,n){let i=new Array(e);if(1==n)for(let n=0;n<e;n++)i[n]=t.readFloat();else for(let a=0;a<e;a++)i[a]=t.readFloat()*n;return i}readShortArray(t){let e=t.readInt(!0),n=new Array(e);for(let i=0;i<e;i++)n[i]=t.readShort();return n}readAnimation(e,n,i){let a=new Array,s=this.scale,r=0,l=new t.Color,o=new t.Color;for(let n=0,i=e.readInt(!0);n<i;n++){let n=e.readInt(!0);for(let i=0,s=e.readInt(!0);i<s;i++){let i=e.readByte(),s=e.readInt(!0);switch(i){case SkeletonBinary.SLOT_ATTACHMENT:{let i=new t.AttachmentTimeline(s);i.slotIndex=n;for(let t=0;t<s;t++)i.setFrame(t,e.readFloat(),e.readStringRef());a.push(i),r=Math.max(r,i.frames[s-1]);break}case SkeletonBinary.SLOT_COLOR:{let i=new t.ColorTimeline(s);i.slotIndex=n;for(let n=0;n<s;n++){let a=e.readFloat();t.Color.rgba8888ToColor(l,e.readInt32()),i.setFrame(n,a,l.r,l.g,l.b,l.a),n<s-1&&this.readCurve(e,n,i)}a.push(i),r=Math.max(r,i.frames[(s-1)*t.ColorTimeline.ENTRIES]);break}case SkeletonBinary.SLOT_TWO_COLOR:{let i=new t.TwoColorTimeline(s);i.slotIndex=n;for(let n=0;n<s;n++){let a=e.readFloat();t.Color.rgba8888ToColor(l,e.readInt32()),t.Color.rgb888ToColor(o,e.readInt32()),i.setFrame(n,a,l.r,l.g,l.b,l.a,o.r,o.g,o.b),n<s-1&&this.readCurve(e,n,i)}a.push(i),r=Math.max(r,i.frames[(s-1)*t.TwoColorTimeline.ENTRIES]);break}}}}for(let n=0,i=e.readInt(!0);n<i;n++){let n=e.readInt(!0);for(let i=0,l=e.readInt(!0);i<l;i++){let i=e.readByte(),l=e.readInt(!0);switch(i){case SkeletonBinary.BONE_ROTATE:{let i=new t.RotateTimeline(l);i.boneIndex=n;for(let t=0;t<l;t++)i.setFrame(t,e.readFloat(),e.readFloat()),t<l-1&&this.readCurve(e,t,i);a.push(i),r=Math.max(r,i.frames[(l-1)*t.RotateTimeline.ENTRIES]);break}case SkeletonBinary.BONE_TRANSLATE:case SkeletonBinary.BONE_SCALE:case SkeletonBinary.BONE_SHEAR:{let o,h=1;i==SkeletonBinary.BONE_SCALE?o=new t.ScaleTimeline(l):i==SkeletonBinary.BONE_SHEAR?o=new t.ShearTimeline(l):(o=new t.TranslateTimeline(l),h=s),o.boneIndex=n;for(let t=0;t<l;t++)o.setFrame(t,e.readFloat(),e.readFloat()*h,e.readFloat()*h),t<l-1&&this.readCurve(e,t,o);a.push(o),r=Math.max(r,o.frames[(l-1)*t.TranslateTimeline.ENTRIES]);break}}}}for(let n=0,i=e.readInt(!0);n<i;n++){let n=e.readInt(!0),i=e.readInt(!0),l=new t.IkConstraintTimeline(i);l.ikConstraintIndex=n;for(let t=0;t<i;t++)l.setFrame(t,e.readFloat(),e.readFloat(),e.readFloat()*s,e.readByte(),e.readBoolean(),e.readBoolean()),t<i-1&&this.readCurve(e,t,l);a.push(l),r=Math.max(r,l.frames[(i-1)*t.IkConstraintTimeline.ENTRIES])}for(let n=0,i=e.readInt(!0);n<i;n++){let n=e.readInt(!0),i=e.readInt(!0),s=new t.TransformConstraintTimeline(i);s.transformConstraintIndex=n;for(let t=0;t<i;t++)s.setFrame(t,e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat(),e.readFloat()),t<i-1&&this.readCurve(e,t,s);a.push(s),r=Math.max(r,s.frames[(i-1)*t.TransformConstraintTimeline.ENTRIES])}for(let n=0,l=e.readInt(!0);n<l;n++){let n=e.readInt(!0),l=i.pathConstraints[n];for(let i=0,o=e.readInt(!0);i<o;i++){let i=e.readByte(),o=e.readInt(!0);switch(i){case SkeletonBinary.PATH_POSITION:case SkeletonBinary.PATH_SPACING:{let h,d=1;i==SkeletonBinary.PATH_SPACING?(h=new t.PathConstraintSpacingTimeline(o),l.spacingMode!=t.SpacingMode.Length&&l.spacingMode!=t.SpacingMode.Fixed||(d=s)):(h=new t.PathConstraintPositionTimeline(o),l.positionMode==t.PositionMode.Fixed&&(d=s)),h.pathConstraintIndex=n;for(let t=0;t<o;t++)h.setFrame(t,e.readFloat(),e.readFloat()*d),t<o-1&&this.readCurve(e,t,h);a.push(h),r=Math.max(r,h.frames[(o-1)*t.PathConstraintPositionTimeline.ENTRIES]);break}case SkeletonBinary.PATH_MIX:{let i=new t.PathConstraintMixTimeline(o);i.pathConstraintIndex=n;for(let t=0;t<o;t++)i.setFrame(t,e.readFloat(),e.readFloat(),e.readFloat()),t<o-1&&this.readCurve(e,t,i);a.push(i),r=Math.max(r,i.frames[(o-1)*t.PathConstraintMixTimeline.ENTRIES]);break}}}}for(let n=0,l=e.readInt(!0);n<l;n++){let n=i.skins[e.readInt(!0)];for(let i=0,l=e.readInt(!0);i<l;i++){let i=e.readInt(!0);for(let l=0,o=e.readInt(!0);l<o;l++){let l=n.getAttachment(i,e.readStringRef()),o=null!=l.bones,h=l.vertices,d=o?h.length/3*2:h.length,u=e.readInt(!0),c=new t.DeformTimeline(u);c.slotIndex=i,c.attachment=l;for(let n=0;n<u;n++){let i,a=e.readFloat(),r=e.readInt(!0);if(0==r)i=o?t.Utils.newFloatArray(d):h;else{i=t.Utils.newFloatArray(d);let n=e.readInt(!0);if(r+=n,1==s)for(let t=n;t<r;t++)i[t]=e.readFloat();else for(let t=n;t<r;t++)i[t]=e.readFloat()*s;if(!o)for(let t=0,e=i.length;t<e;t++)i[t]+=h[t]}c.setFrame(n,a,i),n<u-1&&this.readCurve(e,n,c)}a.push(c),r=Math.max(r,c.frames[u-1])}}}let h=e.readInt(!0);if(h>0){let n=new t.DrawOrderTimeline(h),s=i.slots.length;for(let i=0;i<h;i++){let a=e.readFloat(),r=e.readInt(!0),l=t.Utils.newArray(s,0);for(let t=s-1;t>=0;t--)l[t]=-1;let o=t.Utils.newArray(s-r,0),h=0,d=0;for(let t=0;t<r;t++){let t=e.readInt(!0);for(;h!=t;)o[d++]=h++;l[h+e.readInt(!0)]=h++}for(;h<s;)o[d++]=h++;for(let t=s-1;t>=0;t--)-1==l[t]&&(l[t]=o[--d]);n.setFrame(i,a,l)}a.push(n),r=Math.max(r,n.frames[h-1])}let d=e.readInt(!0);if(d>0){let n=new t.EventTimeline(d);for(let a=0;a<d;a++){let s=e.readFloat(),r=i.events[e.readInt(!0)],l=new t.Event(s,r);l.intValue=e.readInt(!1),l.floatValue=e.readFloat(),l.stringValue=e.readBoolean()?e.readString():r.stringValue,null!=l.data.audioPath&&(l.volume=e.readFloat(),l.balance=e.readFloat()),n.setFrame(a,l)}a.push(n),r=Math.max(r,n.frames[d-1])}return new t.Animation(n,a,r)}readCurve(t,e,n){switch(t.readByte()){case SkeletonBinary.CURVE_STEPPED:n.setStepped(e);break;case SkeletonBinary.CURVE_BEZIER:this.setCurve(n,e,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat())}}setCurve(t,e,n,i,a,s){t.setCurve(e,n,i,a,s)}}SkeletonBinary.AttachmentTypeValues=[0,1,2,3,4,5,6],SkeletonBinary.TransformModeValues=[t.TransformMode.Normal,t.TransformMode.OnlyTranslation,t.TransformMode.NoRotationOrReflection,t.TransformMode.NoScale,t.TransformMode.NoScaleOrReflection],SkeletonBinary.PositionModeValues=[t.PositionMode.Fixed,t.PositionMode.Percent],SkeletonBinary.SpacingModeValues=[t.SpacingMode.Length,t.SpacingMode.Fixed,t.SpacingMode.Percent],SkeletonBinary.RotateModeValues=[t.RotateMode.Tangent,t.RotateMode.Chain,t.RotateMode.ChainScale],SkeletonBinary.BlendModeValues=[t.BlendMode.Normal,t.BlendMode.Additive,t.BlendMode.Multiply,t.BlendMode.Screen],SkeletonBinary.BONE_ROTATE=0,SkeletonBinary.BONE_TRANSLATE=1,SkeletonBinary.BONE_SCALE=2,SkeletonBinary.BONE_SHEAR=3,SkeletonBinary.SLOT_ATTACHMENT=0,SkeletonBinary.SLOT_COLOR=1,SkeletonBinary.SLOT_TWO_COLOR=2,SkeletonBinary.PATH_POSITION=0,SkeletonBinary.PATH_SPACING=1,SkeletonBinary.PATH_MIX=2,SkeletonBinary.CURVE_LINEAR=0,SkeletonBinary.CURVE_STEPPED=1,SkeletonBinary.CURVE_BEZIER=2,t.SkeletonBinary=SkeletonBinary;class BinaryInput{constructor(t,e=new Array,n=0,i=new DataView(t.buffer)){this.strings=e,this.index=n,this.buffer=i}readByte(){return this.buffer.getInt8(this.index++)}readShort(){let t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){let t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),n=127&e;return 0!=(128&e)&&(e=this.readByte(),n|=(127&e)<<7,0!=(128&e)&&(e=this.readByte(),n|=(127&e)<<14,0!=(128&e)&&(e=this.readByte(),n|=(127&e)<<21,0!=(128&e)&&(e=this.readByte(),n|=(127&e)<<28)))),t?n:n>>>1^-(1&n)}readStringRef(){let t=this.readInt(!0);return 0==t?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let n=0;n<t;){let t=this.readByte();switch(t>>4){case 12:case 13:e+=String.fromCharCode((31&t)<<6|63&this.readByte()),n+=2;break;case 14:e+=String.fromCharCode((15&t)<<12|(63&this.readByte())<<6|63&this.readByte()),n+=3;break;default:e+=String.fromCharCode(t),n++}}return e}readFloat(){let t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return 0!=this.readByte()}}class LinkedMesh{constructor(t,e,n,i,a){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=i,this.inheritDeform=a}}class Vertices{constructor(t=null,e=null){this.bones=t,this.vertices=e}}}(spine||(spine={})),function(t){t.SkeletonBounds=class{constructor(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new t.Pool((()=>t.Utils.newFloatArray(16)))}update(e,n){if(null==e)throw new Error("skeleton cannot be null.");let i=this.boundingBoxes,a=this.polygons,s=this.polygonPool,r=e.slots,l=r.length;i.length=0,s.freeAll(a),a.length=0;for(let e=0;e<l;e++){let n=r[e];if(!n.bone.active)continue;let l=n.getAttachment();if(l instanceof t.BoundingBoxAttachment){let e=l;i.push(e);let r=s.obtain();r.length!=e.worldVerticesLength&&(r=t.Utils.newFloatArray(e.worldVerticesLength)),a.push(r),e.computeWorldVertices(n,0,e.worldVerticesLength,r,0,2)}}n?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY,a=this.polygons;for(let s=0,r=a.length;s<r;s++){let r=a[s],l=r;for(let a=0,s=r.length;a<s;a+=2){let s=l[a],r=l[a+1];t=Math.min(t,s),e=Math.min(e,r),n=Math.max(n,s),i=Math.max(i,r)}}this.minX=t,this.minY=e,this.maxX=n,this.maxY=i}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,n,i){let a=this.minX,s=this.minY,r=this.maxX,l=this.maxY;if(t<=a&&n<=a||e<=s&&i<=s||t>=r&&n>=r||e>=l&&i>=l)return!1;let o=(i-e)/(n-t),h=o*(a-t)+e;if(h>s&&h<l)return!0;if(h=o*(r-t)+e,h>s&&h<l)return!0;let d=(s-e)/o+t;return d>a&&d<r||(d=(l-e)/o+t,d>a&&d<r)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){let n=this.polygons;for(let i=0,a=n.length;i<a;i++)if(this.containsPointPolygon(n[i],t,e))return this.boundingBoxes[i];return null}containsPointPolygon(t,e,n){let i=t,a=t.length,s=a-2,r=!1;for(let t=0;t<a;t+=2){let a=i[t+1],l=i[s+1];if(a<n&&l>=n||l<n&&a>=n){let o=i[t];o+(n-a)/(l-a)*(i[s]-o)<e&&(r=!r)}s=t}return r}intersectsSegment(t,e,n,i){let a=this.polygons;for(let s=0,r=a.length;s<r;s++)if(this.intersectsSegmentPolygon(a[s],t,e,n,i))return this.boundingBoxes[s];return null}intersectsSegmentPolygon(t,e,n,i,a){let s=t,r=t.length,l=e-i,o=n-a,h=e*a-n*i,d=s[r-2],u=s[r-1];for(let t=0;t<r;t+=2){let r=s[t],c=s[t+1],m=d*c-u*r,f=d-r,g=u-c,p=l*g-o*f,T=(h*f-l*m)/p;if((T>=d&&T<=r||T>=r&&T<=d)&&(T>=e&&T<=i||T>=i&&T<=e)){let t=(h*g-o*m)/p;if((t>=u&&t<=c||t>=c&&t<=u)&&(t>=n&&t<=a||t>=a&&t<=n))return!0}d=r,u=c}return!1}getPolygon(t){if(null==t)throw new Error("boundingBox cannot be null.");let e=this.boundingBoxes.indexOf(t);return-1==e?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}}(spine||(spine={})),function(t){class SkeletonClipping{constructor(){this.triangulator=new t.Triangulator,this.clippingPolygon=new Array,this.clipOutput=new Array,this.clippedVertices=new Array,this.clippedTriangles=new Array,this.scratch=new Array}clipStart(e,n){if(null!=this.clipAttachment)return 0;this.clipAttachment=n;let i=n.worldVerticesLength,a=t.Utils.setArraySize(this.clippingPolygon,i);n.computeWorldVertices(e,0,i,a,0,2);let s=this.clippingPolygon;SkeletonClipping.makeClockwise(s);let r=this.clippingPolygons=this.triangulator.decompose(s,this.triangulator.triangulate(s));for(let t=0,e=r.length;t<e;t++){let e=r[t];SkeletonClipping.makeClockwise(e),e.push(e[0]),e.push(e[1])}return r.length}clipEndWithSlot(t){null!=this.clipAttachment&&this.clipAttachment.endSlot==t.data&&this.clipEnd()}clipEnd(){null!=this.clipAttachment&&(this.clipAttachment=null,this.clippingPolygons=null,this.clippedVertices.length=0,this.clippedTriangles.length=0,this.clippingPolygon.length=0)}isClipping(){return null!=this.clipAttachment}clipTriangles(e,n,i,a,s,r,l,o){let h=this.clipOutput,d=this.clippedVertices,u=this.clippedTriangles,c=this.clippingPolygons,m=this.clippingPolygons.length,f=o?12:8,g=0;d.length=0,u.length=0;t:for(let n=0;n<a;n+=3){let a=i[n]<<1,p=e[a],T=e[a+1],w=s[a],C=s[a+1];a=i[n+1]<<1;let M=e[a],x=e[a+1],A=s[a],E=s[a+1];a=i[n+2]<<1;let S=e[a],I=e[a+1],y=s[a],R=s[a+1];for(let e=0;e<m;e++){let n=d.length;if(!this.clip(p,T,M,x,S,I,c[e],h)){let e=t.Utils.setArraySize(d,n+3*f);e[n]=p,e[n+1]=T,e[n+2]=r.r,e[n+3]=r.g,e[n+4]=r.b,e[n+5]=r.a,o?(e[n+6]=w,e[n+7]=C,e[n+8]=l.r,e[n+9]=l.g,e[n+10]=l.b,e[n+11]=l.a,e[n+12]=M,e[n+13]=x,e[n+14]=r.r,e[n+15]=r.g,e[n+16]=r.b,e[n+17]=r.a,e[n+18]=A,e[n+19]=E,e[n+20]=l.r,e[n+21]=l.g,e[n+22]=l.b,e[n+23]=l.a,e[n+24]=S,e[n+25]=I,e[n+26]=r.r,e[n+27]=r.g,e[n+28]=r.b,e[n+29]=r.a,e[n+30]=y,e[n+31]=R,e[n+32]=l.r,e[n+33]=l.g,e[n+34]=l.b,e[n+35]=l.a):(e[n+6]=w,e[n+7]=C,e[n+8]=M,e[n+9]=x,e[n+10]=r.r,e[n+11]=r.g,e[n+12]=r.b,e[n+13]=r.a,e[n+14]=A,e[n+15]=E,e[n+16]=S,e[n+17]=I,e[n+18]=r.r,e[n+19]=r.g,e[n+20]=r.b,e[n+21]=r.a,e[n+22]=y,e[n+23]=R),n=u.length;let i=t.Utils.setArraySize(u,n+3);i[n]=g,i[n+1]=g+1,i[n+2]=g+2,g+=3;continue t}{let e=h.length;if(0==e)continue;let i=x-I,a=S-M,s=p-S,c=I-T,m=1/(i*s+a*(T-I)),b=e>>1,P=this.clipOutput,k=t.Utils.setArraySize(d,n+b*f);for(let t=0;t<e;t+=2){let e=P[t],h=P[t+1];k[n]=e,k[n+1]=h,k[n+2]=r.r,k[n+3]=r.g,k[n+4]=r.b,k[n+5]=r.a;let d=e-S,u=h-I,g=(i*d+a*u)*m,p=(c*d+s*u)*m,T=1-g-p;k[n+6]=w*g+A*p+y*T,k[n+7]=C*g+E*p+R*T,o&&(k[n+8]=l.r,k[n+9]=l.g,k[n+10]=l.b,k[n+11]=l.a),n+=f}n=u.length;let V=t.Utils.setArraySize(u,n+3*(b-2));b--;for(let t=1;t<b;t++)V[n]=g,V[n+1]=g+t,V[n+2]=g+t+1,n+=3;g+=b+1}}}}clip(t,e,n,i,a,s,r,l){let o=l,h=!1,d=null;r.length%4>=2?(d=l,l=this.scratch):d=this.scratch,d.length=0,d.push(t),d.push(e),d.push(n),d.push(i),d.push(a),d.push(s),d.push(t),d.push(e),l.length=0;let u=r,c=r.length-4;for(let t=0;;t+=2){let e=u[t],n=u[t+1],i=u[t+2],a=u[t+3],s=e-i,r=n-a,m=d,f=d.length-2,g=l.length;for(let t=0;t<f;t+=2){let o=m[t],d=m[t+1],u=m[t+2],c=m[t+3],f=s*(c-a)-r*(u-i)>0;if(s*(d-a)-r*(o-i)>0){if(f){l.push(u),l.push(c);continue}let t=c-d,s=u-o,r=t*(i-e)-s*(a-n);if(Math.abs(r)>1e-6){let h=(s*(n-d)-t*(e-o))/r;l.push(e+(i-e)*h),l.push(n+(a-n)*h)}else l.push(e),l.push(n)}else if(f){let t=c-d,s=u-o,r=t*(i-e)-s*(a-n);if(Math.abs(r)>1e-6){let h=(s*(n-d)-t*(e-o))/r;l.push(e+(i-e)*h),l.push(n+(a-n)*h)}else l.push(e),l.push(n);l.push(u),l.push(c)}h=!0}if(g==l.length)return o.length=0,!0;if(l.push(l[0]),l.push(l[1]),t==c)break;let p=l;(l=d).length=0,d=p}if(o!=l){o.length=0;for(let t=0,e=l.length-2;t<e;t++)o[t]=l[t]}else o.length=o.length-2;return h}static makeClockwise(t){let e=t,n=t.length,i=e[n-2]*e[1]-e[0]*e[n-1],a=0,s=0,r=0,l=0;for(let t=0,o=n-3;t<o;t+=2)a=e[t],s=e[t+1],r=e[t+2],l=e[t+3],i+=a*l-r*s;if(!(i<0))for(let t=0,i=n-2,a=n>>1;t<a;t+=2){let n=e[t],a=e[t+1],s=i-t;e[t]=e[s],e[t+1]=e[s+1],e[s]=n,e[s+1]=a}}}t.SkeletonClipping=SkeletonClipping}(spine||(spine={})),function(t){t.SkeletonData=class{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(null==t)throw new Error("boneName cannot be null.");let e=this.bones;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.name==t)return i}return null}findBoneIndex(t){if(null==t)throw new Error("boneName cannot be null.");let e=this.bones;for(let n=0,i=e.length;n<i;n++)if(e[n].name==t)return n;return-1}findSlot(t){if(null==t)throw new Error("slotName cannot be null.");let e=this.slots;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.name==t)return i}return null}findSlotIndex(t){if(null==t)throw new Error("slotName cannot be null.");let e=this.slots;for(let n=0,i=e.length;n<i;n++)if(e[n].name==t)return n;return-1}findSkin(t){if(null==t)throw new Error("skinName cannot be null.");let e=this.skins;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.name==t)return i}return null}findEvent(t){if(null==t)throw new Error("eventDataName cannot be null.");let e=this.events;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.name==t)return i}return null}findAnimation(t){if(null==t)throw new Error("animationName cannot be null.");let e=this.animations;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.name==t)return i}return null}findIkConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");let e=this.ikConstraints;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.name==t)return i}return null}findTransformConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");let e=this.transformConstraints;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.name==t)return i}return null}findPathConstraint(t){if(null==t)throw new Error("constraintName cannot be null.");let e=this.pathConstraints;for(let n=0,i=e.length;n<i;n++){let i=e[n];if(i.name==t)return i}return null}findPathConstraintIndex(t){if(null==t)throw new Error("pathConstraintName cannot be null.");let e=this.pathConstraints;for(let n=0,i=e.length;n<i;n++)if(e[n].name==t)return n;return-1}}}(spine||(spine={})),function(t){class SkeletonJson{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(e){let n=this.scale,i=new t.SkeletonData,a="string"==typeof e?JSON.parse(e):e,s=a.skeleton;if(null!=s){if(i.hash=s.hash,i.version=s.spine,"3.8.75"==i.version)throw new Error("Unsupported skeleton data, please export with a newer version of Spine.");i.x=s.x,i.y=s.y,i.width=s.width,i.height=s.height,i.fps=s.fps,i.imagesPath=s.images}if(a.bones)for(let e=0;e<a.bones.length;e++){let s=a.bones[e],r=null,l=this.getValue(s,"parent",null);if(null!=l&&(r=i.findBone(l),null==r))throw new Error("Parent bone not found: "+l);let o=new t.BoneData(i.bones.length,s.name,r);o.length=this.getValue(s,"length",0)*n,o.x=this.getValue(s,"x",0)*n,o.y=this.getValue(s,"y",0)*n,o.rotation=this.getValue(s,"rotation",0),o.scaleX=this.getValue(s,"scaleX",1),o.scaleY=this.getValue(s,"scaleY",1),o.shearX=this.getValue(s,"shearX",0),o.shearY=this.getValue(s,"shearY",0),o.transformMode=SkeletonJson.transformModeFromString(this.getValue(s,"transform","normal")),o.skinRequired=this.getValue(s,"skin",!1),i.bones.push(o)}if(a.slots)for(let e=0;e<a.slots.length;e++){let n=a.slots[e],s=n.name,r=n.bone,l=i.findBone(r);if(null==l)throw new Error("Slot bone not found: "+r);let o=new t.SlotData(i.slots.length,s,l),h=this.getValue(n,"color",null);null!=h&&o.color.setFromString(h);let d=this.getValue(n,"dark",null);null!=d&&(o.darkColor=new t.Color(1,1,1,1),o.darkColor.setFromString(d)),o.attachmentName=this.getValue(n,"attachment",null),o.blendMode=SkeletonJson.blendModeFromString(this.getValue(n,"blend","normal")),i.slots.push(o)}if(a.ik)for(let e=0;e<a.ik.length;e++){let s=a.ik[e],r=new t.IkConstraintData(s.name);r.order=this.getValue(s,"order",0),r.skinRequired=this.getValue(s,"skin",!1);for(let t=0;t<s.bones.length;t++){let e=s.bones[t],n=i.findBone(e);if(null==n)throw new Error("IK bone not found: "+e);r.bones.push(n)}let l=s.target;if(r.target=i.findBone(l),null==r.target)throw new Error("IK target bone not found: "+l);r.mix=this.getValue(s,"mix",1),r.softness=this.getValue(s,"softness",0)*n,r.bendDirection=this.getValue(s,"bendPositive",!0)?1:-1,r.compress=this.getValue(s,"compress",!1),r.stretch=this.getValue(s,"stretch",!1),r.uniform=this.getValue(s,"uniform",!1),i.ikConstraints.push(r)}if(a.transform)for(let e=0;e<a.transform.length;e++){let s=a.transform[e],r=new t.TransformConstraintData(s.name);r.order=this.getValue(s,"order",0),r.skinRequired=this.getValue(s,"skin",!1);for(let t=0;t<s.bones.length;t++){let e=s.bones[t],n=i.findBone(e);if(null==n)throw new Error("Transform constraint bone not found: "+e);r.bones.push(n)}let l=s.target;if(r.target=i.findBone(l),null==r.target)throw new Error("Transform constraint target bone not found: "+l);r.local=this.getValue(s,"local",!1),r.relative=this.getValue(s,"relative",!1),r.offsetRotation=this.getValue(s,"rotation",0),r.offsetX=this.getValue(s,"x",0)*n,r.offsetY=this.getValue(s,"y",0)*n,r.offsetScaleX=this.getValue(s,"scaleX",0),r.offsetScaleY=this.getValue(s,"scaleY",0),r.offsetShearY=this.getValue(s,"shearY",0),r.rotateMix=this.getValue(s,"rotateMix",1),r.translateMix=this.getValue(s,"translateMix",1),r.scaleMix=this.getValue(s,"scaleMix",1),r.shearMix=this.getValue(s,"shearMix",1),i.transformConstraints.push(r)}if(a.path)for(let e=0;e<a.path.length;e++){let s=a.path[e],r=new t.PathConstraintData(s.name);r.order=this.getValue(s,"order",0),r.skinRequired=this.getValue(s,"skin",!1);for(let t=0;t<s.bones.length;t++){let e=s.bones[t],n=i.findBone(e);if(null==n)throw new Error("Transform constraint bone not found: "+e);r.bones.push(n)}let l=s.target;if(r.target=i.findSlot(l),null==r.target)throw new Error("Path target slot not found: "+l);r.positionMode=SkeletonJson.positionModeFromString(this.getValue(s,"positionMode","percent")),r.spacingMode=SkeletonJson.spacingModeFromString(this.getValue(s,"spacingMode","length")),r.rotateMode=SkeletonJson.rotateModeFromString(this.getValue(s,"rotateMode","tangent")),r.offsetRotation=this.getValue(s,"rotation",0),r.position=this.getValue(s,"position",0),r.positionMode==t.PositionMode.Fixed&&(r.position*=n),r.spacing=this.getValue(s,"spacing",0),r.spacingMode!=t.SpacingMode.Length&&r.spacingMode!=t.SpacingMode.Fixed||(r.spacing*=n),r.rotateMix=this.getValue(s,"rotateMix",1),r.translateMix=this.getValue(s,"translateMix",1),i.pathConstraints.push(r)}if(a.skins)for(let e=0;e<a.skins.length;e++){let n=a.skins[e],s=new t.Skin(n.name);if(n.bones)for(let t=0;t<n.bones.length;t++){let a=i.findBone(n.bones[t]);if(null==a)throw new Error("Skin bone not found: "+n.bones[e]);s.bones.push(a)}if(n.ik)for(let t=0;t<n.ik.length;t++){let a=i.findIkConstraint(n.ik[t]);if(null==a)throw new Error("Skin IK constraint not found: "+n.ik[e]);s.constraints.push(a)}if(n.transform)for(let t=0;t<n.transform.length;t++){let a=i.findTransformConstraint(n.transform[t]);if(null==a)throw new Error("Skin transform constraint not found: "+n.transform[e]);s.constraints.push(a)}if(n.path)for(let t=0;t<n.path.length;t++){let a=i.findPathConstraint(n.path[t]);if(null==a)throw new Error("Skin path constraint not found: "+n.path[e]);s.constraints.push(a)}for(let t in n.attachments){let e=i.findSlot(t);if(null==e)throw new Error("Slot not found: "+t);let a=n.attachments[t];for(let t in a){let n=this.readAttachment(a[t],s,e.index,t,i);null!=n&&s.setAttachment(e.index,t,n)}}i.skins.push(s),"default"==s.name&&(i.defaultSkin=s)}for(let t=0,e=this.linkedMeshes.length;t<e;t++){let e=this.linkedMeshes[t],n=null==e.skin?i.defaultSkin:i.findSkin(e.skin);if(null==n)throw new Error("Skin not found: "+e.skin);let a=n.getAttachment(e.slotIndex,e.parent);if(null==a)throw new Error("Parent mesh not found: "+e.parent);e.mesh.deformAttachment=e.inheritDeform?a:e.mesh,e.mesh.setParentMesh(a),e.mesh.updateUVs()}if(this.linkedMeshes.length=0,a.events)for(let e in a.events){let n=a.events[e],s=new t.EventData(e);s.intValue=this.getValue(n,"int",0),s.floatValue=this.getValue(n,"float",0),s.stringValue=this.getValue(n,"string",""),s.audioPath=this.getValue(n,"audio",null),null!=s.audioPath&&(s.volume=this.getValue(n,"volume",1),s.balance=this.getValue(n,"balance",0)),i.events.push(s)}if(a.animations)for(let t in a.animations){let e=a.animations[t];this.readAnimation(e,t,i)}return i}readAttachment(e,n,i,a,s){let r=this.scale;switch(a=this.getValue(e,"name",a),this.getValue(e,"type","region")){case"region":{let t=this.getValue(e,"path",a),i=this.attachmentLoader.newRegionAttachment(n,a,t);if(null==i)return null;i.path=t,i.x=this.getValue(e,"x",0)*r,i.y=this.getValue(e,"y",0)*r,i.scaleX=this.getValue(e,"scaleX",1),i.scaleY=this.getValue(e,"scaleY",1),i.rotation=this.getValue(e,"rotation",0),i.width=e.width*r,i.height=e.height*r;let s=this.getValue(e,"color",null);return null!=s&&i.color.setFromString(s),i.updateOffset(),i}case"boundingbox":{let t=this.attachmentLoader.newBoundingBoxAttachment(n,a);if(null==t)return null;this.readVertices(e,t,e.vertexCount<<1);let i=this.getValue(e,"color",null);return null!=i&&t.color.setFromString(i),t}case"mesh":case"linkedmesh":{let t=this.getValue(e,"path",a),s=this.attachmentLoader.newMeshAttachment(n,a,t);if(null==s)return null;s.path=t;let l=this.getValue(e,"color",null);null!=l&&s.color.setFromString(l),s.width=this.getValue(e,"width",0)*r,s.height=this.getValue(e,"height",0)*r;let o=this.getValue(e,"parent",null);if(null!=o)return this.linkedMeshes.push(new LinkedMesh(s,this.getValue(e,"skin",null),i,o,this.getValue(e,"deform",!0))),s;let h=e.uvs;return this.readVertices(e,s,h.length),s.triangles=e.triangles,s.regionUVs=h,s.updateUVs(),s.edges=this.getValue(e,"edges",null),s.hullLength=2*this.getValue(e,"hull",0),s}case"path":{let i=this.attachmentLoader.newPathAttachment(n,a);if(null==i)return null;i.closed=this.getValue(e,"closed",!1),i.constantSpeed=this.getValue(e,"constantSpeed",!0);let s=e.vertexCount;this.readVertices(e,i,s<<1);let l=t.Utils.newArray(s/3,0);for(let t=0;t<e.lengths.length;t++)l[t]=e.lengths[t]*r;i.lengths=l;let o=this.getValue(e,"color",null);return null!=o&&i.color.setFromString(o),i}case"point":{let t=this.attachmentLoader.newPointAttachment(n,a);if(null==t)return null;t.x=this.getValue(e,"x",0)*r,t.y=this.getValue(e,"y",0)*r,t.rotation=this.getValue(e,"rotation",0);let i=this.getValue(e,"color",null);return null!=i&&t.color.setFromString(i),t}case"clipping":{let t=this.attachmentLoader.newClippingAttachment(n,a);if(null==t)return null;let i=this.getValue(e,"end",null);if(null!=i){let e=s.findSlot(i);if(null==e)throw new Error("Clipping end slot not found: "+i);t.endSlot=e}let r=e.vertexCount;this.readVertices(e,t,r<<1);let l=this.getValue(e,"color",null);return null!=l&&t.color.setFromString(l),t}}return null}readVertices(e,n,i){let a=this.scale;n.worldVerticesLength=i;let s=e.vertices;if(i==s.length){let e=t.Utils.toFloatArray(s);if(1!=a)for(let t=0,n=s.length;t<n;t++)e[t]*=a;return void(n.vertices=e)}let r=new Array,l=new Array;for(let t=0,e=s.length;t<e;){let e=s[t++];l.push(e);for(let n=t+4*e;t<n;t+=4)l.push(s[t]),r.push(s[t+1]*a),r.push(s[t+2]*a),r.push(s[t+3])}n.bones=l,n.vertices=t.Utils.toFloatArray(r)}readAnimation(e,n,i){let a=this.scale,s=new Array,r=0;if(e.slots)for(let n in e.slots){let a=e.slots[n],l=i.findSlotIndex(n);if(-1==l)throw new Error("Slot not found: "+n);for(let e in a){let i=a[e];if("attachment"==e){let e=new t.AttachmentTimeline(i.length);e.slotIndex=l;let n=0;for(let t=0;t<i.length;t++){let a=i[t];e.setFrame(n++,this.getValue(a,"time",0),a.name)}s.push(e),r=Math.max(r,e.frames[e.getFrameCount()-1])}else if("color"==e){let e=new t.ColorTimeline(i.length);e.slotIndex=l;let n=0;for(let a=0;a<i.length;a++){let s=i[a],r=new t.Color;r.setFromString(s.color),e.setFrame(n,this.getValue(s,"time",0),r.r,r.g,r.b,r.a),this.readCurve(s,e,n),n++}s.push(e),r=Math.max(r,e.frames[(e.getFrameCount()-1)*t.ColorTimeline.ENTRIES])}else{if("twoColor"!=e)throw new Error("Invalid timeline type for a slot: "+e+" ("+n+")");{let e=new t.TwoColorTimeline(i.length);e.slotIndex=l;let n=0;for(let a=0;a<i.length;a++){let s=i[a],r=new t.Color,l=new t.Color;r.setFromString(s.light),l.setFromString(s.dark),e.setFrame(n,this.getValue(s,"time",0),r.r,r.g,r.b,r.a,l.r,l.g,l.b),this.readCurve(s,e,n),n++}s.push(e),r=Math.max(r,e.frames[(e.getFrameCount()-1)*t.TwoColorTimeline.ENTRIES])}}}}if(e.bones)for(let n in e.bones){let l=e.bones[n],o=i.findBoneIndex(n);if(-1==o)throw new Error("Bone not found: "+n);for(let e in l){let i=l[e];if("rotate"===e){let e=new t.RotateTimeline(i.length);e.boneIndex=o;let n=0;for(let t=0;t<i.length;t++){let a=i[t];e.setFrame(n,this.getValue(a,"time",0),this.getValue(a,"angle",0)),this.readCurve(a,e,n),n++}s.push(e),r=Math.max(r,e.frames[(e.getFrameCount()-1)*t.RotateTimeline.ENTRIES])}else{if("translate"!==e&&"scale"!==e&&"shear"!==e)throw new Error("Invalid timeline type for a bone: "+e+" ("+n+")");{let n=null,l=1,h=0;"scale"===e?(n=new t.ScaleTimeline(i.length),h=1):"shear"===e?n=new t.ShearTimeline(i.length):(n=new t.TranslateTimeline(i.length),l=a),n.boneIndex=o;let d=0;for(let t=0;t<i.length;t++){let e=i[t],a=this.getValue(e,"x",h),s=this.getValue(e,"y",h);n.setFrame(d,this.getValue(e,"time",0),a*l,s*l),this.readCurve(e,n,d),d++}s.push(n),r=Math.max(r,n.frames[(n.getFrameCount()-1)*t.TranslateTimeline.ENTRIES])}}}}if(e.ik)for(let n in e.ik){let l=e.ik[n],o=i.findIkConstraint(n),h=new t.IkConstraintTimeline(l.length);h.ikConstraintIndex=i.ikConstraints.indexOf(o);let d=0;for(let t=0;t<l.length;t++){let e=l[t];h.setFrame(d,this.getValue(e,"time",0),this.getValue(e,"mix",1),this.getValue(e,"softness",0)*a,this.getValue(e,"bendPositive",!0)?1:-1,this.getValue(e,"compress",!1),this.getValue(e,"stretch",!1)),this.readCurve(e,h,d),d++}s.push(h),r=Math.max(r,h.frames[(h.getFrameCount()-1)*t.IkConstraintTimeline.ENTRIES])}if(e.transform)for(let n in e.transform){let a=e.transform[n],l=i.findTransformConstraint(n),o=new t.TransformConstraintTimeline(a.length);o.transformConstraintIndex=i.transformConstraints.indexOf(l);let h=0;for(let t=0;t<a.length;t++){let e=a[t];o.setFrame(h,this.getValue(e,"time",0),this.getValue(e,"rotateMix",1),this.getValue(e,"translateMix",1),this.getValue(e,"scaleMix",1),this.getValue(e,"shearMix",1)),this.readCurve(e,o,h),h++}s.push(o),r=Math.max(r,o.frames[(o.getFrameCount()-1)*t.TransformConstraintTimeline.ENTRIES])}if(e.path)for(let n in e.path){let l=e.path[n],o=i.findPathConstraintIndex(n);if(-1==o)throw new Error("Path constraint not found: "+n);let h=i.pathConstraints[o];for(let e in l){let n=l[e];if("position"===e||"spacing"===e){let i=null,l=1;"spacing"===e?(i=new t.PathConstraintSpacingTimeline(n.length),h.spacingMode!=t.SpacingMode.Length&&h.spacingMode!=t.SpacingMode.Fixed||(l=a)):(i=new t.PathConstraintPositionTimeline(n.length),h.positionMode==t.PositionMode.Fixed&&(l=a)),i.pathConstraintIndex=o;let d=0;for(let t=0;t<n.length;t++){let a=n[t];i.setFrame(d,this.getValue(a,"time",0),this.getValue(a,e,0)*l),this.readCurve(a,i,d),d++}s.push(i),r=Math.max(r,i.frames[(i.getFrameCount()-1)*t.PathConstraintPositionTimeline.ENTRIES])}else if("mix"===e){let e=new t.PathConstraintMixTimeline(n.length);e.pathConstraintIndex=o;let i=0;for(let t=0;t<n.length;t++){let a=n[t];e.setFrame(i,this.getValue(a,"time",0),this.getValue(a,"rotateMix",1),this.getValue(a,"translateMix",1)),this.readCurve(a,e,i),i++}s.push(e),r=Math.max(r,e.frames[(e.getFrameCount()-1)*t.PathConstraintMixTimeline.ENTRIES])}}}if(e.deform)for(let n in e.deform){let l=e.deform[n],o=i.findSkin(n);if(null==o)throw new Error("Skin not found: "+n);for(let e in l){let n=l[e],h=i.findSlotIndex(e);if(-1==h)throw new Error("Slot not found: "+n.name);for(let e in n){let i=n[e],l=o.getAttachment(h,e);if(null==l)throw new Error("Deform attachment not found: "+i.name);let d=null!=l.bones,u=l.vertices,c=d?u.length/3*2:u.length,m=new t.DeformTimeline(i.length);m.slotIndex=h,m.attachment=l;let f=0;for(let e=0;e<i.length;e++){let n,s=i[e],r=this.getValue(s,"vertices",null);if(null==r)n=d?t.Utils.newFloatArray(c):u;else{n=t.Utils.newFloatArray(c);let e=this.getValue(s,"offset",0);if(t.Utils.arrayCopy(r,0,n,e,r.length),1!=a)for(let t=e,i=t+r.length;t<i;t++)n[t]*=a;if(!d)for(let t=0;t<c;t++)n[t]+=u[t]}m.setFrame(f,this.getValue(s,"time",0),n),this.readCurve(s,m,f),f++}s.push(m),r=Math.max(r,m.frames[m.getFrameCount()-1])}}}let l=e.drawOrder;if(null==l&&(l=e.draworder),null!=l){let e=new t.DrawOrderTimeline(l.length),n=i.slots.length,a=0;for(let s=0;s<l.length;s++){let r=l[s],o=null,h=this.getValue(r,"offsets",null);if(null!=h){o=t.Utils.newArray(n,-1);let e=t.Utils.newArray(n-h.length,0),a=0,s=0;for(let t=0;t<h.length;t++){let n=h[t],r=i.findSlotIndex(n.slot);if(-1==r)throw new Error("Slot not found: "+n.slot);for(;a!=r;)e[s++]=a++;o[a+n.offset]=a++}for(;a<n;)e[s++]=a++;for(let t=n-1;t>=0;t--)-1==o[t]&&(o[t]=e[--s])}e.setFrame(a++,this.getValue(r,"time",0),o)}s.push(e),r=Math.max(r,e.frames[e.getFrameCount()-1])}if(e.events){let n=new t.EventTimeline(e.events.length),a=0;for(let s=0;s<e.events.length;s++){let r=e.events[s],l=i.findEvent(r.name);if(null==l)throw new Error("Event not found: "+r.name);let o=new t.Event(t.Utils.toSinglePrecision(this.getValue(r,"time",0)),l);o.intValue=this.getValue(r,"int",l.intValue),o.floatValue=this.getValue(r,"float",l.floatValue),o.stringValue=this.getValue(r,"string",l.stringValue),null!=o.data.audioPath&&(o.volume=this.getValue(r,"volume",1),o.balance=this.getValue(r,"balance",0)),n.setFrame(a++,o)}s.push(n),r=Math.max(r,n.frames[n.getFrameCount()-1])}if(isNaN(r))throw new Error("Error while parsing animation, duration is NaN");i.animations.push(new t.Animation(n,s,r))}readCurve(t,e,n){if(t.hasOwnProperty("curve"))if("stepped"==t.curve)e.setStepped(n);else{let i=t.curve;e.setCurve(n,i,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,e,n){return void 0!==t[e]?t[e]:n}static blendModeFromString(e){if("normal"==(e=e.toLowerCase()))return t.BlendMode.Normal;if("additive"==e)return t.BlendMode.Additive;if("multiply"==e)return t.BlendMode.Multiply;if("screen"==e)return t.BlendMode.Screen;throw new Error(`Unknown blend mode: ${e}`)}static positionModeFromString(e){if("fixed"==(e=e.toLowerCase()))return t.PositionMode.Fixed;if("percent"==e)return t.PositionMode.Percent;throw new Error(`Unknown position mode: ${e}`)}static spacingModeFromString(e){if("length"==(e=e.toLowerCase()))return t.SpacingMode.Length;if("fixed"==e)return t.SpacingMode.Fixed;if("percent"==e)return t.SpacingMode.Percent;throw new Error(`Unknown position mode: ${e}`)}static rotateModeFromString(e){if("tangent"==(e=e.toLowerCase()))return t.RotateMode.Tangent;if("chain"==e)return t.RotateMode.Chain;if("chainscale"==e)return t.RotateMode.ChainScale;throw new Error(`Unknown rotate mode: ${e}`)}static transformModeFromString(e){if("normal"==(e=e.toLowerCase()))return t.TransformMode.Normal;if("onlytranslation"==e)return t.TransformMode.OnlyTranslation;if("norotationorreflection"==e)return t.TransformMode.NoRotationOrReflection;if("noscale"==e)return t.TransformMode.NoScale;if("noscaleorreflection"==e)return t.TransformMode.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${e}`)}}t.SkeletonJson=SkeletonJson;class LinkedMesh{constructor(t,e,n,i,a){this.mesh=t,this.skin=e,this.slotIndex=n,this.parent=i,this.inheritDeform=a}}}(spine||(spine={})),function(t){class SkinEntry{constructor(t,e,n){this.slotIndex=t,this.name=e,this.attachment=n}}t.SkinEntry=SkinEntry;t.Skin=class{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,null==t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,n){if(null==n)throw new Error("attachment cannot be null.");let i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][e]=n}addSkin(t){for(let e=0;e<t.bones.length;e++){let n=t.bones[e],i=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==n){i=!0;break}i||this.bones.push(n)}for(let e=0;e<t.constraints.length;e++){let n=t.constraints[e],i=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==n){i=!0;break}i||this.constraints.push(n)}let e=t.getAttachments();for(let t=0;t<e.length;t++){var n=e[t];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(e){for(let t=0;t<e.bones.length;t++){let n=e.bones[t],i=!1;for(let t=0;t<this.bones.length;t++)if(this.bones[t]==n){i=!0;break}i||this.bones.push(n)}for(let t=0;t<e.constraints.length;t++){let n=e.constraints[t],i=!1;for(let t=0;t<this.constraints.length;t++)if(this.constraints[t]==n){i=!0;break}i||this.constraints.push(n)}let n=e.getAttachments();for(let e=0;e<n.length;e++){var i=n[e];null!=i.attachment&&(i.attachment instanceof t.MeshAttachment?(i.attachment=i.attachment.newLinkedMesh(),this.setAttachment(i.slotIndex,i.name,i.attachment)):(i.attachment=i.attachment.copy(),this.setAttachment(i.slotIndex,i.name,i.attachment)))}}getAttachment(t,e){let n=this.attachments[t];return n?n[e]:null}removeAttachment(t,e){let n=this.attachments[t];n&&(n[e]=null)}getAttachments(){let t=new Array;for(var e=0;e<this.attachments.length;e++){let n=this.attachments[e];if(n)for(let i in n){let a=n[i];a&&t.push(new SkinEntry(e,i,a))}}return t}getAttachmentsForSlot(t,e){let n=this.attachments[t];if(n)for(let i in n){let a=n[i];a&&e.push(new SkinEntry(t,i,a))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let n=0;for(let i=0;i<t.slots.length;i++){let a=t.slots[i],s=a.getAttachment();if(s&&n<e.attachments.length){let t=e.attachments[n];for(let e in t){if(s==t[e]){let t=this.getAttachment(n,e);null!=t&&a.setAttachment(t);break}}}n++}}}}(spine||(spine={})),function(t){t.Slot=class{constructor(e,n){if(this.deform=new Array,null==e)throw new Error("data cannot be null.");if(null==n)throw new Error("bone cannot be null.");this.data=e,this.bone=n,this.color=new t.Color,this.darkColor=null==e.darkColor?null:new t.Color,this.setToSetupPose()}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),null!=this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),null==this.data.attachmentName?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}}(spine||(spine={})),function(t){t.SlotData=class{constructor(e,n,i){if(this.color=new t.Color(1,1,1,1),e<0)throw new Error("index must be >= 0.");if(null==n)throw new Error("name cannot be null.");if(null==i)throw new Error("boneData cannot be null.");this.index=e,this.name=n,this.boneData=i}}}(spine||(spine={})),function(t){class Texture{constructor(t){this._image=t}getImage(){return this._image}static filterFromString(t){switch(t.toLowerCase()){case"nearest":return e.Nearest;case"linear":return e.Linear;case"mipmap":return e.MipMap;case"mipmapnearestnearest":return e.MipMapNearestNearest;case"mipmaplinearnearest":return e.MipMapLinearNearest;case"mipmapnearestlinear":return e.MipMapNearestLinear;case"mipmaplinearlinear":return e.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${t}`)}}static wrapFromString(t){switch(t.toLowerCase()){case"mirroredtepeat":return n.MirroredRepeat;case"clamptoedge":return n.ClampToEdge;case"repeat":return n.Repeat;default:throw new Error(`Unknown texture wrap ${t}`)}}}let e,n;t.Texture=Texture,function(t){t[t.Nearest=9728]="Nearest",t[t.Linear=9729]="Linear",t[t.MipMap=9987]="MipMap",t[t.MipMapNearestNearest=9984]="MipMapNearestNearest",t[t.MipMapLinearNearest=9985]="MipMapLinearNearest",t[t.MipMapNearestLinear=9986]="MipMapNearestLinear",t[t.MipMapLinearLinear=9987]="MipMapLinearLinear"}(e=t.TextureFilter||(t.TextureFilter={})),function(t){t[t.MirroredRepeat=33648]="MirroredRepeat",t[t.ClampToEdge=33071]="ClampToEdge",t[t.Repeat=10497]="Repeat"}(n=t.TextureWrap||(t.TextureWrap={}));t.TextureRegion=class{constructor(){this.u=0,this.v=0,this.u2=0,this.v2=0,this.width=0,this.height=0,this.rotate=!1,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0}};t.FakeTexture=class extends Texture{setFilters(t,e){}setWraps(t,e){}dispose(){}}}(spine||(spine={})),function(t){t.TextureAtlas=class{constructor(t,e){this.pages=new Array,this.regions=new Array,this.load(t,e)}load(e,n){if(null==n)throw new Error("textureLoader cannot be null.");let i=new TextureAtlasReader(e),a=new Array(4),s=null;for(;;){let e=i.readLine();if(null==e)break;if(e=e.trim(),0==e.length)s=null;else if(s){let t=new TextureAtlasRegion;t.name=e,t.page=s;let n=i.readValue();"true"==n.toLocaleLowerCase()?t.degrees=90:"false"==n.toLocaleLowerCase()?t.degrees=0:t.degrees=parseFloat(n),t.rotate=90==t.degrees,i.readTuple(a);let r=parseInt(a[0]),l=parseInt(a[1]);i.readTuple(a);let o=parseInt(a[0]),h=parseInt(a[1]);t.u=r/s.width,t.v=l/s.height,t.rotate?(t.u2=(r+h)/s.width,t.v2=(l+o)/s.height):(t.u2=(r+o)/s.width,t.v2=(l+h)/s.height),t.x=r,t.y=l,t.width=Math.abs(o),t.height=Math.abs(h),4==i.readTuple(a)&&4==i.readTuple(a)&&i.readTuple(a),t.originalWidth=parseInt(a[0]),t.originalHeight=parseInt(a[1]),i.readTuple(a),t.offsetX=parseInt(a[0]),t.offsetY=parseInt(a[1]),t.index=parseInt(i.readValue()),t.texture=s.texture,this.regions.push(t)}else{s=new TextureAtlasPage,s.name=e,2==i.readTuple(a)&&(s.width=parseInt(a[0]),s.height=parseInt(a[1]),i.readTuple(a)),i.readTuple(a),s.minFilter=t.Texture.filterFromString(a[0]),s.magFilter=t.Texture.filterFromString(a[1]);let r=i.readValue();s.uWrap=t.TextureWrap.ClampToEdge,s.vWrap=t.TextureWrap.ClampToEdge,"x"==r?s.uWrap=t.TextureWrap.Repeat:"y"==r?s.vWrap=t.TextureWrap.Repeat:"xy"==r&&(s.uWrap=s.vWrap=t.TextureWrap.Repeat),s.texture=n(e),s.texture.setFilters(s.minFilter,s.magFilter),s.texture.setWraps(s.uWrap,s.vWrap),s.width=s.texture.getImage().width,s.height=s.texture.getImage().height,this.pages.push(s)}}}findRegion(t){for(let e=0;e<this.regions.length;e++)if(this.regions[e].name==t)return this.regions[e];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].texture.dispose()}};class TextureAtlasReader{constructor(t){this.index=0,this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readValue(){let t=this.readLine(),e=t.indexOf(":");if(-1==e)throw new Error("Invalid line: "+t);return t.substring(e+1).trim()}readTuple(t){let e=this.readLine(),n=e.indexOf(":");if(-1==n)throw new Error("Invalid line: "+e);let i=0,a=n+1;for(;i<3;i++){let n=e.indexOf(",",a);if(-1==n)break;t[i]=e.substr(a,n-a).trim(),a=n+1}return t[i]=e.substring(a).trim(),i+1}}class TextureAtlasPage{}t.TextureAtlasPage=TextureAtlasPage;class TextureAtlasRegion extends t.TextureRegion{}t.TextureAtlasRegion=TextureAtlasRegion}(spine||(spine={})),function(t){t.TransformConstraint=class{constructor(e,n){if(this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.temp=new t.Vector2,this.active=!1,null==e)throw new Error("data cannot be null.");if(null==n)throw new Error("skeleton cannot be null.");this.data=e,this.rotateMix=e.rotateMix,this.translateMix=e.translateMix,this.scaleMix=e.scaleMix,this.shearMix=e.shearMix,this.bones=new Array;for(let t=0;t<e.bones.length;t++)this.bones.push(n.findBone(e.bones[t].name));this.target=n.findBone(e.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){let e=this.rotateMix,n=this.translateMix,i=this.scaleMix,a=this.shearMix,s=this.target,r=s.a,l=s.b,o=s.c,h=s.d,d=r*h-l*o>0?t.MathUtils.degRad:-t.MathUtils.degRad,u=this.data.offsetRotation*d,c=this.data.offsetShearY*d,m=this.bones;for(let d=0,f=m.length;d<f;d++){let f=m[d],g=!1;if(0!=e){let n=f.a,i=f.b,a=f.c,s=f.d,l=Math.atan2(o,r)-Math.atan2(a,n)+u;l>t.MathUtils.PI?l-=t.MathUtils.PI2:l<-t.MathUtils.PI&&(l+=t.MathUtils.PI2),l*=e;let h=Math.cos(l),d=Math.sin(l);f.a=h*n-d*a,f.b=h*i-d*s,f.c=d*n+h*a,f.d=d*i+h*s,g=!0}if(0!=n){let t=this.temp;s.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),f.worldX+=(t.x-f.worldX)*n,f.worldY+=(t.y-f.worldY)*n,g=!0}if(i>0){let t=Math.sqrt(f.a*f.a+f.c*f.c),e=Math.sqrt(r*r+o*o);t>1e-5&&(t=(t+(e-t+this.data.offsetScaleX)*i)/t),f.a*=t,f.c*=t,t=Math.sqrt(f.b*f.b+f.d*f.d),e=Math.sqrt(l*l+h*h),t>1e-5&&(t=(t+(e-t+this.data.offsetScaleY)*i)/t),f.b*=t,f.d*=t,g=!0}if(a>0){let e=f.b,n=f.d,i=Math.atan2(n,e),s=Math.atan2(h,l)-Math.atan2(o,r)-(i-Math.atan2(f.c,f.a));s>t.MathUtils.PI?s-=t.MathUtils.PI2:s<-t.MathUtils.PI&&(s+=t.MathUtils.PI2),s=i+(s+c)*a;let d=Math.sqrt(e*e+n*n);f.b=Math.cos(s)*d,f.d=Math.sin(s)*d,g=!0}g&&(f.appliedValid=!1)}}applyRelativeWorld(){let e=this.rotateMix,n=this.translateMix,i=this.scaleMix,a=this.shearMix,s=this.target,r=s.a,l=s.b,o=s.c,h=s.d,d=r*h-l*o>0?t.MathUtils.degRad:-t.MathUtils.degRad,u=this.data.offsetRotation*d,c=this.data.offsetShearY*d,m=this.bones;for(let d=0,f=m.length;d<f;d++){let f=m[d],g=!1;if(0!=e){let n=f.a,i=f.b,a=f.c,s=f.d,l=Math.atan2(o,r)+u;l>t.MathUtils.PI?l-=t.MathUtils.PI2:l<-t.MathUtils.PI&&(l+=t.MathUtils.PI2),l*=e;let h=Math.cos(l),d=Math.sin(l);f.a=h*n-d*a,f.b=h*i-d*s,f.c=d*n+h*a,f.d=d*i+h*s,g=!0}if(0!=n){let t=this.temp;s.localToWorld(t.set(this.data.offsetX,this.data.offsetY)),f.worldX+=t.x*n,f.worldY+=t.y*n,g=!0}if(i>0){let t=(Math.sqrt(r*r+o*o)-1+this.data.offsetScaleX)*i+1;f.a*=t,f.c*=t,t=(Math.sqrt(l*l+h*h)-1+this.data.offsetScaleY)*i+1,f.b*=t,f.d*=t,g=!0}if(a>0){let e=Math.atan2(h,l)-Math.atan2(o,r);e>t.MathUtils.PI?e-=t.MathUtils.PI2:e<-t.MathUtils.PI&&(e+=t.MathUtils.PI2);let n=f.b,i=f.d;e=Math.atan2(i,n)+(e-t.MathUtils.PI/2+c)*a;let s=Math.sqrt(n*n+i*i);f.b=Math.cos(e)*s,f.d=Math.sin(e)*s,g=!0}g&&(f.appliedValid=!1)}}applyAbsoluteLocal(){let t=this.rotateMix,e=this.translateMix,n=this.scaleMix,i=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();let s=this.bones;for(let r=0,l=s.length;r<l;r++){let l=s[r];l.appliedValid||l.updateAppliedTransform();let o=l.arotation;if(0!=t){let e=a.arotation-o+this.data.offsetRotation;e-=360*(16384-(16384.499999999996-e/360|0)),o+=e*t}let h=l.ax,d=l.ay;0!=e&&(h+=(a.ax-h+this.data.offsetX)*e,d+=(a.ay-d+this.data.offsetY)*e);let u=l.ascaleX,c=l.ascaleY;0!=n&&(u>1e-5&&(u=(u+(a.ascaleX-u+this.data.offsetScaleX)*n)/u),c>1e-5&&(c=(c+(a.ascaleY-c+this.data.offsetScaleY)*n)/c));let m=l.ashearY;if(0!=i){let t=a.ashearY-m+this.data.offsetShearY;t-=360*(16384-(16384.499999999996-t/360|0)),l.shearY+=t*i}l.updateWorldTransformWith(h,d,o,u,c,l.ashearX,m)}}applyRelativeLocal(){let t=this.rotateMix,e=this.translateMix,n=this.scaleMix,i=this.shearMix,a=this.target;a.appliedValid||a.updateAppliedTransform();let s=this.bones;for(let r=0,l=s.length;r<l;r++){let l=s[r];l.appliedValid||l.updateAppliedTransform();let o=l.arotation;0!=t&&(o+=(a.arotation+this.data.offsetRotation)*t);let h=l.ax,d=l.ay;0!=e&&(h+=(a.ax+this.data.offsetX)*e,d+=(a.ay+this.data.offsetY)*e);let u=l.ascaleX,c=l.ascaleY;0!=n&&(u>1e-5&&(u*=(a.ascaleX-1+this.data.offsetScaleX)*n+1),c>1e-5&&(c*=(a.ascaleY-1+this.data.offsetScaleY)*n+1));let m=l.ashearY;0!=i&&(m+=(a.ashearY+this.data.offsetShearY)*i),l.updateWorldTransformWith(h,d,o,u,c,l.ashearX,m)}}}}(spine||(spine={})),function(t){class TransformConstraintData extends t.ConstraintData{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}t.TransformConstraintData=TransformConstraintData}(spine||(spine={})),function(t){class Triangulator{constructor(){this.convexPolygons=new Array,this.convexPolygonsIndices=new Array,this.indicesArray=new Array,this.isConcaveArray=new Array,this.triangles=new Array,this.polygonPool=new t.Pool((()=>new Array)),this.polygonIndicesPool=new t.Pool((()=>new Array))}triangulate(t){let e=t,n=t.length>>1,i=this.indicesArray;i.length=0;for(let t=0;t<n;t++)i[t]=t;let a=this.isConcaveArray;a.length=0;for(let t=0,s=n;t<s;++t)a[t]=Triangulator.isConcave(t,n,e,i);let s=this.triangles;for(s.length=0;n>3;){let t=n-1,r=0,l=1;for(;;){t:if(!a[r]){let s=i[t]<<1,o=i[r]<<1,h=i[l]<<1,d=e[s],u=e[s+1],c=e[o],m=e[o+1],f=e[h],g=e[h+1];for(let s=(l+1)%n;s!=t;s=(s+1)%n){if(!a[s])continue;let t=i[s]<<1,n=e[t],r=e[t+1];if(Triangulator.positiveArea(f,g,d,u,n,r)&&Triangulator.positiveArea(d,u,c,m,n,r)&&Triangulator.positiveArea(c,m,f,g,n,r))break t}break}if(0==l){do{if(!a[r])break;r--}while(r>0);break}t=r,r=l,l=(l+1)%n}s.push(i[(n+r-1)%n]),s.push(i[r]),s.push(i[(r+1)%n]),i.splice(r,1),a.splice(r,1),n--;let o=(n+r-1)%n,h=r==n?0:r;a[o]=Triangulator.isConcave(o,n,e,i),a[h]=Triangulator.isConcave(h,n,e,i)}return 3==n&&(s.push(i[2]),s.push(i[0]),s.push(i[1])),s}decompose(t,e){let n=t,i=this.convexPolygons;this.polygonPool.freeAll(i),i.length=0;let a=this.convexPolygonsIndices;this.polygonIndicesPool.freeAll(a),a.length=0;let s=this.polygonIndicesPool.obtain();s.length=0;let r=this.polygonPool.obtain();r.length=0;let l=-1,o=0;for(let t=0,h=e.length;t<h;t+=3){let h=e[t]<<1,d=e[t+1]<<1,u=e[t+2]<<1,c=n[h],m=n[h+1],f=n[d],g=n[d+1],p=n[u],T=n[u+1],w=!1;if(l==h){let t=r.length-4,e=Triangulator.winding(r[t],r[t+1],r[t+2],r[t+3],p,T),n=Triangulator.winding(p,T,r[0],r[1],r[2],r[3]);e==o&&n==o&&(r.push(p),r.push(T),s.push(u),w=!0)}w||(r.length>0?(i.push(r),a.push(s)):(this.polygonPool.free(r),this.polygonIndicesPool.free(s)),r=this.polygonPool.obtain(),r.length=0,r.push(c),r.push(m),r.push(f),r.push(g),r.push(p),r.push(T),s=this.polygonIndicesPool.obtain(),s.length=0,s.push(h),s.push(d),s.push(u),o=Triangulator.winding(c,m,f,g,p,T),l=h)}r.length>0&&(i.push(r),a.push(s));for(let t=0,e=i.length;t<e;t++){if(s=a[t],0==s.length)continue;let n=s[0],l=s[s.length-1];r=i[t];let o=r.length-4,h=r[o],d=r[o+1],u=r[o+2],c=r[o+3],m=r[0],f=r[1],g=r[2],p=r[3],T=Triangulator.winding(h,d,u,c,m,f);for(let o=0;o<e;o++){if(o==t)continue;let e=a[o];if(3!=e.length)continue;let w=e[0],C=e[1],M=e[2],x=i[o],A=x[x.length-2],E=x[x.length-1];if(w!=n||C!=l)continue;let S=Triangulator.winding(h,d,u,c,A,E),I=Triangulator.winding(A,E,m,f,g,p);S==T&&I==T&&(x.length=0,e.length=0,r.push(A),r.push(E),s.push(M),h=u,d=c,u=A,c=E,o=0)}}for(let t=i.length-1;t>=0;t--)r=i[t],0==r.length&&(i.splice(t,1),this.polygonPool.free(r),s=a[t],a.splice(t,1),this.polygonIndicesPool.free(s));return i}static isConcave(t,e,n,i){let a=i[(e+t-1)%e]<<1,s=i[t]<<1,r=i[(t+1)%e]<<1;return!this.positiveArea(n[a],n[a+1],n[s],n[s+1],n[r],n[r+1])}static positiveArea(t,e,n,i,a,s){return t*(s-i)+n*(e-s)+a*(i-e)>=0}static winding(t,e,n,i,a,s){let r=n-t,l=i-e;return a*l-s*r+r*e-t*l>=0?1:-1}}t.Triangulator=Triangulator}(spine||(spine={})),function(t){t.IntSet=class{constructor(){this.array=new Array}add(t){let e=this.contains(t);return this.array[0|t]=0|t,!e}contains(t){return null!=this.array[0|t]}remove(t){this.array[0|t]=void 0}clear(){this.array.length=0}};class Color{constructor(t=0,e=0,n=0,i=0){this.r=t,this.g=e,this.b=n,this.a=i}set(t,e,n,i){return this.r=t,this.g=e,this.b=n,this.a=i,this.clamp(),this}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t="#"==t.charAt(0)?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=(8!=t.length?255:parseInt(t.substr(6,2),16))/255,this}add(t,e,n,i){return this.r+=t,this.g+=e,this.b+=n,this.a+=i,this.clamp(),this}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((4278190080&e)>>>24)/255,t.g=((16711680&e)>>>16)/255,t.b=((65280&e)>>>8)/255,t.a=(255&e)/255}static rgb888ToColor(t,e){t.r=((16711680&e)>>>16)/255,t.g=((65280&e)>>>8)/255,t.b=(255&e)/255}}Color.WHITE=new Color(1,1,1,1),Color.RED=new Color(1,0,0,1),Color.GREEN=new Color(0,1,0,1),Color.BLUE=new Color(0,0,1,1),Color.MAGENTA=new Color(1,0,1,1),t.Color=Color;class MathUtils{static clamp(t,e,n){return t<e?e:t>n?n:t}static cosDeg(t){return Math.cos(t*MathUtils.degRad)}static sinDeg(t){return Math.sin(t*MathUtils.degRad)}static signum(t){return t>0?1:t<0?-1:0}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){let e=Math.pow(Math.abs(t),1/3);return t<0?-e:e}static randomTriangular(t,e){return MathUtils.randomTriangularWith(t,e,.5*(t+e))}static randomTriangularWith(t,e,n){let i=Math.random(),a=e-t;return i<=(n-t)/a?t+Math.sqrt(i*a*(n-t)):e-Math.sqrt((1-i)*a*(e-n))}}MathUtils.PI=3.1415927,MathUtils.PI2=2*MathUtils.PI,MathUtils.radiansToDegrees=180/MathUtils.PI,MathUtils.radDeg=MathUtils.radiansToDegrees,MathUtils.degreesToRadians=MathUtils.PI/180,MathUtils.degRad=MathUtils.degreesToRadians,t.MathUtils=MathUtils;class Interpolation{apply(t,e,n){return t+(e-t)*this.applyInternal(n)}}t.Interpolation=Interpolation;class Pow extends Interpolation{constructor(t){super(),this.power=2,this.power=t}applyInternal(t){return t<=.5?Math.pow(2*t,this.power)/2:Math.pow(2*(t-1),this.power)/(this.power%2==0?-2:2)+1}}t.Pow=Pow;t.PowOut=class extends Pow{constructor(t){super(t)}applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}};class Utils{static arrayCopy(t,e,n,i,a){for(let s=e,r=i;s<e+a;s++,r++)n[r]=t[s]}static setArraySize(t,e,n=0){let i=t.length;if(i==e)return t;if(t.length=e,i<e)for(let a=i;a<e;a++)t[a]=n;return t}static ensureArrayCapacity(t,e,n=0){return t.length>=e?t:Utils.setArraySize(t,e,n)}static newArray(t,e){let n=new Array(t);for(let i=0;i<t;i++)n[i]=e;return n}static newFloatArray(t){if(Utils.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);{let e=new Array(t);for(let t=0;t<e.length;t++)e[t]=0;return e}}static newShortArray(t){if(Utils.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);{let e=new Array(t);for(let t=0;t<e.length;t++)e[t]=0;return e}}static toFloatArray(t){return Utils.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Utils.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,n=!0){for(var i=0;i<t.length;i++)if(t[i]==e)return!0;return!1}}Utils.SUPPORTS_TYPED_ARRAYS="undefined"!=typeof Float32Array,t.Utils=Utils;t.DebugUtils=class{static logBones(t){for(let e=0;e<t.bones.length;e++){let n=t.bones[e];console.log(n.data.name+", "+n.a+", "+n.b+", "+n.c+", "+n.d+", "+n.worldX+", "+n.worldY)}}};t.Pool=class{constructor(t){this.items=new Array,this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}};t.Vector2=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){let t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){let t=this.length();return 0!=t&&(this.x/=t,this.y/=t),this}};t.TimeKeeper=class{constructor(){this.maxDelta=.064,this.framesPerSecond=0,this.delta=0,this.totalTime=0,this.lastTime=Date.now()/1e3,this.frameCount=0,this.frameTime=0}update(){let t=Date.now()/1e3;this.delta=t-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=t,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}};t.WindowedMean=class{constructor(t=32){this.addedValues=0,this.lastValue=0,this.mean=0,this.dirty=!0,this.values=new Array(t)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(t){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=t,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let t=0;for(let e=0;e<this.values.length;e++)t+=this.values[e];this.mean=t/this.values.length,this.dirty=!1}return this.mean}return 0}}}(spine||(spine={})),(()=>{var t;Math.fround||(Math.fround=(t=new Float32Array(1),function(e){return t[0]=e,t[0]}))})(),function(t){class Attachment{constructor(t){if(null==t)throw new Error("name cannot be null.");this.name=t}}t.Attachment=Attachment;class VertexAttachment extends Attachment{constructor(t){super(t),this.id=(65535&VertexAttachment.nextID++)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVertices(t,e,n,i,a,s){n=a+(n>>1)*s;let r=t.bone.skeleton,l=t.deform,o=this.vertices,h=this.bones;if(null==h){l.length>0&&(o=l);let r=t.bone,h=r.worldX,d=r.worldY,u=r.a,c=r.b,m=r.c,f=r.d;for(let t=e,r=a;r<n;t+=2,r+=s){let e=o[t],n=o[t+1];i[r]=e*u+n*c+h,i[r+1]=e*m+n*f+d}return}let d=0,u=0;for(let t=0;t<e;t+=2){let t=h[d];d+=t+1,u+=t}let c=r.bones;if(0==l.length)for(let t=a,e=3*u;t<n;t+=s){let n=0,a=0,s=h[d++];for(s+=d;d<s;d++,e+=3){let t=c[h[d]],i=o[e],s=o[e+1],r=o[e+2];n+=(i*t.a+s*t.b+t.worldX)*r,a+=(i*t.c+s*t.d+t.worldY)*r}i[t]=n,i[t+1]=a}else{let t=l;for(let e=a,r=3*u,l=u<<1;e<n;e+=s){let n=0,a=0,s=h[d++];for(s+=d;d<s;d++,r+=3,l+=2){let e=c[h[d]],i=o[r]+t[l],s=o[r+1]+t[l+1],u=o[r+2];n+=(i*e.a+s*e.b+e.worldX)*u,a+=(i*e.c+s*e.d+e.worldY)*u}i[e]=n,i[e+1]=a}}}copyTo(e){null!=this.bones?(e.bones=new Array(this.bones.length),t.Utils.arrayCopy(this.bones,0,e.bones,0,this.bones.length)):e.bones=null,null!=this.vertices?(e.vertices=t.Utils.newFloatArray(this.vertices.length),t.Utils.arrayCopy(this.vertices,0,e.vertices,0,this.vertices.length)):e.vertices=null,e.worldVerticesLength=this.worldVerticesLength,e.deformAttachment=this.deformAttachment}}VertexAttachment.nextID=0,t.VertexAttachment=VertexAttachment}(spine||(spine={})),function(t){let e;!function(t){t[t.Region=0]="Region",t[t.BoundingBox=1]="BoundingBox",t[t.Mesh=2]="Mesh",t[t.LinkedMesh=3]="LinkedMesh",t[t.Path=4]="Path",t[t.Point=5]="Point",t[t.Clipping=6]="Clipping"}(e=t.AttachmentType||(t.AttachmentType={}))}(spine||(spine={})),function(t){class BoundingBoxAttachment extends t.VertexAttachment{constructor(e){super(e),this.color=new t.Color(1,1,1,1)}copy(){let t=new BoundingBoxAttachment(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}t.BoundingBoxAttachment=BoundingBoxAttachment}(spine||(spine={})),function(t){class ClippingAttachment extends t.VertexAttachment{constructor(e){super(e),this.color=new t.Color(.2275,.2275,.8078,1)}copy(){let t=new ClippingAttachment(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}t.ClippingAttachment=ClippingAttachment}(spine||(spine={})),function(t){class MeshAttachment extends t.VertexAttachment{constructor(e){super(e),this.color=new t.Color(1,1,1,1),this.tempColor=new t.Color(0,0,0,0)}updateUVs(){let e=this.regionUVs;null!=this.uvs&&this.uvs.length==e.length||(this.uvs=t.Utils.newFloatArray(e.length));let n=this.uvs,i=this.uvs.length,a=this.region.u,s=this.region.v,r=0,l=0;if(this.region instanceof t.TextureAtlasRegion){let t=this.region,o=t.texture.getImage().width,h=t.texture.getImage().height;switch(t.degrees){case 90:a-=(t.originalHeight-t.offsetY-t.height)/o,s-=(t.originalWidth-t.offsetX-t.width)/h,r=t.originalHeight/o,l=t.originalWidth/h;for(let t=0;t<i;t+=2)n[t]=a+e[t+1]*r,n[t+1]=s+(1-e[t])*l;return;case 180:a-=(t.originalWidth-t.offsetX-t.width)/o,s-=t.offsetY/h,r=t.originalWidth/o,l=t.originalHeight/h;for(let t=0;t<i;t+=2)n[t]=a+(1-e[t])*r,n[t+1]=s+(1-e[t+1])*l;return;case 270:a-=t.offsetY/o,s-=t.offsetX/h,r=t.originalHeight/o,l=t.originalWidth/h;for(let t=0;t<i;t+=2)n[t]=a+(1-e[t+1])*r,n[t+1]=s+e[t]*l;return}a-=t.offsetX/o,s-=(t.originalHeight-t.offsetY-t.height)/h,r=t.originalWidth/o,l=t.originalHeight/h}else null==this.region?(a=s=0,r=l=1):(r=this.region.u2-a,l=this.region.v2-s);for(let t=0;t<i;t+=2)n[t]=a+e[t]*r,n[t+1]=s+e[t+1]*l}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,null!=t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(null!=this.parentMesh)return this.newLinkedMesh();let e=new MeshAttachment(this.name);return e.region=this.region,e.path=this.path,e.color.setFromColor(this.color),this.copyTo(e),e.regionUVs=new Array(this.regionUVs.length),t.Utils.arrayCopy(this.regionUVs,0,e.regionUVs,0,this.regionUVs.length),e.uvs=new Array(this.uvs.length),t.Utils.arrayCopy(this.uvs,0,e.uvs,0,this.uvs.length),e.triangles=new Array(this.triangles.length),t.Utils.arrayCopy(this.triangles,0,e.triangles,0,this.triangles.length),e.hullLength=this.hullLength,null!=this.edges&&(e.edges=new Array(this.edges.length),t.Utils.arrayCopy(this.edges,0,e.edges,0,this.edges.length)),e.width=this.width,e.height=this.height,e}newLinkedMesh(){let t=new MeshAttachment(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(null!=this.parentMesh?this.parentMesh:this),t.updateUVs(),t}}t.MeshAttachment=MeshAttachment}(spine||(spine={})),function(t){class PathAttachment extends t.VertexAttachment{constructor(e){super(e),this.closed=!1,this.constantSpeed=!1,this.color=new t.Color(1,1,1,1)}copy(){let e=new PathAttachment(this.name);return this.copyTo(e),e.lengths=new Array(this.lengths.length),t.Utils.arrayCopy(this.lengths,0,e.lengths,0,this.lengths.length),e.closed=closed,e.constantSpeed=this.constantSpeed,e.color.setFromColor(this.color),e}}t.PathAttachment=PathAttachment}(spine||(spine={})),function(t){class PointAttachment extends t.VertexAttachment{constructor(e){super(e),this.color=new t.Color(.38,.94,0,1)}computeWorldPosition(t,e){return e.x=this.x*t.a+this.y*t.b+t.worldX,e.y=this.x*t.c+this.y*t.d+t.worldY,e}computeWorldRotation(e){let n=t.MathUtils.cosDeg(this.rotation),i=t.MathUtils.sinDeg(this.rotation),a=n*e.a+i*e.b,s=n*e.c+i*e.d;return Math.atan2(s,a)*t.MathUtils.radDeg}copy(){let t=new PointAttachment(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}t.PointAttachment=PointAttachment}(spine||(spine={})),function(t){class RegionAttachment extends t.Attachment{constructor(e){super(e),this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new t.Color(1,1,1,1),this.offset=t.Utils.newFloatArray(8),this.uvs=t.Utils.newFloatArray(8),this.tempColor=new t.Color(1,1,1,1)}updateOffset(){let t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*t,i=-this.height/2*this.scaleY+this.region.offsetY*e,a=n+this.region.width*t,s=i+this.region.height*e,r=this.rotation*Math.PI/180,l=Math.cos(r),o=Math.sin(r),h=n*l+this.x,d=n*o,u=i*l+this.y,c=i*o,m=a*l+this.x,f=a*o,g=s*l+this.y,p=s*o,T=this.offset;T[RegionAttachment.OX1]=h-c,T[RegionAttachment.OY1]=u+d,T[RegionAttachment.OX2]=h-p,T[RegionAttachment.OY2]=g+d,T[RegionAttachment.OX3]=m-p,T[RegionAttachment.OY3]=g+f,T[RegionAttachment.OX4]=m-c,T[RegionAttachment.OY4]=u+f}setRegion(t){this.region=t;let e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,n,i){let a=this.offset,s=t.worldX,r=t.worldY,l=t.a,o=t.b,h=t.c,d=t.d,u=0,c=0;u=a[RegionAttachment.OX1],c=a[RegionAttachment.OY1],e[n]=u*l+c*o+s,e[n+1]=u*h+c*d+r,n+=i,u=a[RegionAttachment.OX2],c=a[RegionAttachment.OY2],e[n]=u*l+c*o+s,e[n+1]=u*h+c*d+r,n+=i,u=a[RegionAttachment.OX3],c=a[RegionAttachment.OY3],e[n]=u*l+c*o+s,e[n+1]=u*h+c*d+r,n+=i,u=a[RegionAttachment.OX4],c=a[RegionAttachment.OY4],e[n]=u*l+c*o+s,e[n+1]=u*h+c*d+r}copy(){let e=new RegionAttachment(this.name);return e.region=this.region,e.rendererObject=this.rendererObject,e.path=this.path,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,t.Utils.arrayCopy(this.uvs,0,e.uvs,0,8),t.Utils.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e}}RegionAttachment.OX1=0,RegionAttachment.OY1=1,RegionAttachment.OX2=2,RegionAttachment.OY2=3,RegionAttachment.OX3=4,RegionAttachment.OY3=5,RegionAttachment.OX4=6,RegionAttachment.OY4=7,RegionAttachment.X1=0,RegionAttachment.Y1=1,RegionAttachment.C1R=2,RegionAttachment.C1G=3,RegionAttachment.C1B=4,RegionAttachment.C1A=5,RegionAttachment.U1=6,RegionAttachment.V1=7,RegionAttachment.X2=8,RegionAttachment.Y2=9,RegionAttachment.C2R=10,RegionAttachment.C2G=11,RegionAttachment.C2B=12,RegionAttachment.C2A=13,RegionAttachment.U2=14,RegionAttachment.V2=15,RegionAttachment.X3=16,RegionAttachment.Y3=17,RegionAttachment.C3R=18,RegionAttachment.C3G=19,RegionAttachment.C3B=20,RegionAttachment.C3A=21,RegionAttachment.U3=22,RegionAttachment.V3=23,RegionAttachment.X4=24,RegionAttachment.Y4=25,RegionAttachment.C4R=26,RegionAttachment.C4G=27,RegionAttachment.C4B=28,RegionAttachment.C4A=29,RegionAttachment.U4=30,RegionAttachment.V4=31,t.RegionAttachment=RegionAttachment}(spine||(spine={})),function(t){t.JitterEffect=class{constructor(t,e){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=e}begin(t){}transform(e,n,i,a){e.x+=t.MathUtils.randomTriangular(-this.jitterX,this.jitterY),e.y+=t.MathUtils.randomTriangular(-this.jitterX,this.jitterY)}end(){}}}(spine||(spine={})),function(t){class SwirlEffect{constructor(t){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(e,n,i,a){let s=this.angle*t.MathUtils.degreesToRadians,r=e.x-this.worldX,l=e.y-this.worldY,o=Math.sqrt(r*r+l*l);if(o<this.radius){let t=SwirlEffect.interpolation.apply(0,s,(this.radius-o)/this.radius),n=Math.cos(t),i=Math.sin(t);e.x=n*r-i*l+this.worldX,e.y=i*r+n*l+this.worldY}}end(){}}SwirlEffect.interpolation=new t.PowOut(2),t.SwirlEffect=SwirlEffect}(spine||(spine={})),window.spine=spine;